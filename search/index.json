[{"content":"编译-GCC13.2.0-x64-2023-12-29 编译器版本\nMinGW-w64版本：x86_64-13.2.0-release-posix-seh-ucrt-rt_v11-rev1.7z\ngcc version 13.2.0 (x86_64-posix-seh-rev1, Built by MinGW-Builds project)\ngcc.exe (x86_64-posix-seh-rev1, Built by MinGW-Builds project) 13.2.0\nD:\\MinGW-w64-ucrt\\bin\\g++.exe\n生成\u0026quot;D:\\Code\\boost_1_84_0\\b2.exe\u0026quot;\n1 2 cd D:\\Code\\boost_1_84_0 bootstrap gcc 编译\n1 b2 -j16 --build-dir=.\\TYbuild --build-type=complete --prefix=.\\gcc1320_x64 link=static,shared threading=single,multi runtime-link=static,shared address-model=64 toolset=gcc variant=debug,release install 备注\n-jN：同时使用N个子线程编译，根据机器需要选取不同的线程数目 \u0026ndash;build-dir：编译生成的中间文件的路径。默认为X:\\boost_X_XX_X\\boost\\bin.v2，等编译完成后删除 \u0026ndash;build-type= 编译类型，可选minimal（最小）、complete（完整），默认minimal。 \u0026ndash;with- 加入此参数，代表只编译的库。 \u0026ndash;without- 加入此参数，代表忽略编译的库。 \u0026ndash;without/\u0026ndash;with：选择不编译/编译哪些库。因为python、mpi等库我都用不着，所以排除之。还有wave、graph、math、regex、test、program_options、serialization、signals这几个库编出的静态lib都非常大，所以不需要的也可以without。这可以根据各人需要进行选择，默认是全部编译。但是需要注意，如果选择编译python的话，是需要python语言支持的，可以到python官方主页下载安装。查看boost包含库的命令是bjam \u0026ndash;show-libraries。 \u0026ndash;layout=versioned link：生成动态链接库/静态链接库。生成动态链接库需使用shared方式，生成静态链接库需使用static方式。一般boost库可能都是以static方式编译，因为最终发布程序带着boost的dll感觉会比较累赘。 threading：单/多线程编译。一般都写多线程程序，当然要指定multi方式了；如果需要编写单线程程序，那么还需要编译单线程库，可以使用single方式。 stage/install：stage表示只生成库（dll和lib），install还会生成包含头文件的include目录。推荐使用stage，因为install生成的这个include目录实际就是boost安装包解压缩后的boost目录（X:\\boost_X_XX_X\\boost，只比include目录多几个非hpp文件，都很小），所以可以直接使用，而且不同的IDE都可以使用同一套头文件，这样既节省编译时间，也节省硬盘空间。 runtime-link：动态/静态链接C/C++运行时库。同样有shared和static两种方式，这样runtime-link和link一共可以产生4种组合方式，各人可以根据自己的需要选择编译。 toolset：指定编译器，可选的如borland、gcc、msvc（VC6）、msvc-10.0（VS2010）、msvc-12.0（VS2013）、msvc-14.0（VS2015）等。 stagedir/\u0026ndash;prefix：stage时使用stagedir，install时使用prefix，表示编译生成文件的路径。推荐给不同的IDE指定不同的目录，如VS2015对应的是 X:\\boost_X_XX_X\\vc10,如果使用了install参数，那么还将生成头文件目录，vc10对应的就是X:\\boost_X_XX_X\\boost\\bin\\vc10\\include\\boost_X_XX_X\\boost variant：编译debug/release版本。一般都是程序的debug版本对应库的debug版本，所以两个都编译。那么如果需要生成dll，可以使用link=shared方式生成。 编译-GCC13.2.0-x64-2023-12-29 编译器版本\nMinGW-w64版本：x86_64-13.2.0-release-win32-seh-ucrt-rt_v11-rev1.7z 生成\u0026quot;D:\\Code\\boost_1_83_0\\b2.exe\u0026quot;\n1 2 cd D:\\Code\\boost_1_83_0 bootstrap gcc 编译\n1 b2 -j16 --build-dir=.\\tmp --build-type=complete threading=multi link=shared address-model=64 toolset=gcc stage 备注\n“stage”表示生成的Boost库文件会存储于“D:\\Code\\boost_1_83_0\\stage\\lib”文件夹。 库命名规则：可参考：库命名举例.xlsx .a 静态链接库link=static\n.dll、.dll.a 动态链接库link=shared\n在大多数unix平台上：.so是共享库。.a是静态库 在 Windows上：.dll表示共享库，.lib是静态或导入库。\ns 静态链接C/C++运行时库runtime-link=static\n无s 动态链接C/C++运行时库runtime-link=shared\n无d variant=release版本\nd variant=debug版本\nmt 多线程threading=multi\n无mt 单线程threading=single\ng：使用标准库和运行时支撑库的调试版本\ny：使用 Python的特殊调试构建\np：使用 STLPort标准库而不是编译器提供的默认库\nn：使用 STLPort已被弃用的\u0026quot;native iostreams\u0026quot;\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/%E7%BC%96%E7%A8%8B/cpp-boost-%E7%BC%96%E8%AF%91/","title":"boost库编译"},{"content":"参考资料 Kawaii-gcc本地 Kawaii-gcc网站 ArchLinux设置简体中文 Linux环境 安装中文 (如果没有安装)\n1 sudo apt-get install language-pack-zh-hans language-pack-zh-hans-base 安装 gcc , gettext 和 g++.\n1 sudo apt-get install gcc gettext g++ 安装 gcc locales\n通过以下命令检查你的gcc版本号\n1 gcc -v 我这里是12.3.0.所以我的主版本号是12，安装gcc-12-locales\n1 sudo apt-get install gcc-12-locales 找到你的语言文件的路径。默认会在 /usr/share/locale/zh_CN/LC_MESSAGES/gcc.mo. 不过你也有可能找不到该文件或者找到名为gcc-12.mo的文件。\n如果你在上个步骤找到了相关文件，请直接使用原本的名字。 如果没有，首先使用 gcc-\u0026lt;主版本号\u0026gt;.mo 。如果发现不起作用，将其重命名为 gcc.mo. 修改环境变量以将终端语言改为中文：\n1 2 3 4 5 6 7 8 vim ~/.bashrc # Add the following lines export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LANGUAGE=\u0026#34;zh_CN.UTF-8\u0026#34; # Save it in Vim source ~/.bashrc 实测ArchLinux 已经是中文版 已安装gcc gettext g++ gcc版本为13 没有gcc-13-locales、但有/usr/share/locale/zh_CN/LC_MESSAGES/gcc.mo 只要按上述将终端语言改为中文即可 将gcc.mo替换为kawaii-gcc中的prebuilt/gcc-zh.mo(需重命名为gcc.mo)可成功 将gcc.mo替换为mingw64\\share\\locale\\zh_CN\\LC_MESSAGES\\gcc.mo可成功 实测Ubuntu 22.04 已经是中文版 已安装gcc gettext g++ gcc-11-locales gcc版本为11 将/usr/share/locale-langpack/zh_CN/LC_MESSAGES/gcc.mo复制到/usr/share/locale/zh_CN/LC_MESSAGES/，并改名为gcc-11.mo 按上述将终端语言改为中文即可 备注： 无论是ArchLinux和Ubuntu，我确保设置了\n/etc/locale.gen\n1 zh_CN.UTF-8 UTF-8 /etc/locale.conf (经验证在Ubuntu 22.04上不需要也可以)\n1 LANG=zh_CN.UTF-8 这两个文件我放在\u0026quot;\\192.168.96.2\\ypr-pc\\软件\\Linux\\ArchLinux\\locale配置文件.rar\u0026quot;\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/%E7%BC%96%E7%A8%8B/cpp-gcc-%E6%9C%AC%E5%9C%B0%E5%8C%96-linux/","title":"GCC本地化-Linux"},{"content":" 让你的GCC编译器变得可爱！\n本项目通过修改GCC的输出信息的本地化文件的方式让GCC变得可爱。\n欢迎贡献更多有趣的内容。\n依赖 GNU GCC GNU Gettext 如何使用？ Linux (以Ubuntu为例) 中文版使用教程视频-Bilibili\n日语版使用教程视频-Bilibili\n日语版使用教程视频-YouTube\n安装中文 (如果没有安装)\n1 sudo apt-get install language-pack-zh-hans language-pack-zh-hans-base 安装 gcc , gettext 和 g++.\n1 sudo apt-get install gcc gettext g++ 安装 gcc locales\n通过以下命令检查你的gcc版本号\n1 gcc -v 我这里是12.3.0.所以我的主版本号是12，安装gcc-12-locales\n1 sudo apt-get install gcc-12-locales 找到你的语言文件的路径。默认会在 /usr/share/locale/zh_CN/LC_MESSAGES/gcc.mo. 不过你也有可能找不到该文件或者找到名为gcc-12.mo的文件。如果已有相关文件，备份之。 (eg. sudo mv gcc-12.mo gcc-12.mo.bak) 如果没有相关文件，无需担心，什么都不需要做。\n通过以下命令下载仓库中的mo 文件然后将其复制到刚才的路径去。\n1 sudo wget https://github.com/Bill-Haku/kawaii-gcc/raw/main/prebuilt/gcc-zh.mo -O /usr/share/locale/zh_CN/LC_MESSAGES/gcc-12.mo 您也可以自行重新编译该二进制文件：\n1 2 3 make merge-zh msgfmt gcc-zh.po -o gcc.mo sudo cp gcc.mo /usr/share/locale/zh_CN/LC_MESSAGES/gcc-12.mo 或\n1 make 关于文件名：\n如果你在上个步骤找到了相关文件，请直接使用原本的名字。 如果没有，首先使用 gcc-\u0026lt;主版本号\u0026gt;.mo 。如果发现不起作用，将其重命名为 gcc.mo. 修改环境变量以将终端语言改为中文：\n1 2 3 4 5 6 7 8 vim ~/.bashrc # Add the following lines export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LANGUAGE=\u0026#34;zh_CN.UTF-8\u0026#34; # Save it in Vim source ~/.bashrc 现在你的GCC已经变得可爱了。\n你可以使用附带的 test.cc 来试试效果。\n1 2 gcc test.cc -Wall # -Wall 表示让GCC输出所有警告信息 Windows 安装 Cygwin。\n步骤：\n下载并运行 setup-x86_64.exe 在 选择下载源 (Choose A Download Source) 步骤时选择 从互联网安装 (Install from Internet)\n在 选择软件包 (Select Packages) 步骤时, 将查看 (View) 设为 类别 (Category) 并依次搜索 (Search) 并选择 ALL/Devel 下的 gcc-core，gcc-g++ 和 gettext 的版本 假设你的 Cygwin 安装目录 (注意不是软件包下载目录) 为 \u0026lt;DIR\u0026gt; (默认应该是 C:\\cygwin), 将目录 \u0026lt;DIR\u0026gt;\\bin 目录添加到环境变量 Path 中 (如果 Path 中已经有 mingw 了, 请删除或者移到\u0026lt;DIR\u0026gt;\\bin的下方), 并额外增加一条环境变量 LANG, 设置为 zh_CN.UTF-8\n将本仓库的 prebuilt 目录下的 gcc-zh.mo 放到 \u0026lt;DIR\u0026gt;\\usr\\share\\locale\\zh_CN\\LC_MESSAGES 目录下, 并将其重命名为 gcc.mo (建议先将原来的gcc.mo备份)\nmacOS 暂未实现。欢迎贡献。\n如何修改/贡献 前往./src目录，使用文本编辑器打开并编辑zh-kawaii.po。可以修改已有的内容，也可以根据原始简体中文本地化文件增加新内容。编辑完成后运行make指令合并文件，并将其编译成mo文件后拷贝到指定的地方。\n关于src目录下的文件 zh_CN.po: GNU提供的原始简体中文版本地化文件。 zh_kawaii.po: 本项目已修改的本地化内容。 如果您愿意参与贡献本项目 请在PR时将您修改完成的编译好的mo文件放在../prebuilt目录下，以更新预编译好的本地化二进制文件。\nStar History 特别鸣谢 本项目的灵感来自gcc-hentai项目。为了将其推广到日语区，我创建了本仓库、制作了日语版并修改完善了使用说明的诸多细节，最后制作了完全日语的宣传视频发布在YouTube，不料却在Bilibili获得了关注。十分感谢原作者的分享和开源精神。\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/%E7%BC%96%E7%A8%8B/cpp-gcc-kawaii-gcc/","title":"Kawaii-gcc 让GCC变得可爱"},{"content":"教程 菜鸟教程：https://www.runoob.com/markdown/md-tutorial.html\n软件 Visual Studio Code Visual Studio Code 是众所周知的神器，是微软推出一款轻量级的文本编辑工具，类似于 Sublime，它已经默认集成 Markdown 文档编辑插件，原生就支持高亮 Markdown 的语法，但想要实时预览还需要选择 Markdown: Open Preview to the Side 命令实现，相关教程请点击此处\nhttps://www.cnblogs.com/shawWey/p/8931697.html\nTypora 官网：https://typora.io/\n中文官网：https://typoraio.cn/\n果核剥壳：https://www.ghxi.com/typora.html\nMarkText 官网：https://marktext.app/\nGitHub：https://github.com/marktext/marktext\nGitHub中文包：https://github.com/chinayangxiaowei/marktext-chinese-language-pack\n中文说明书：https://zhuanlan.zhihu.com/p/438852089\n相关介绍：\nhttps://zhuanlan.zhihu.com/p/348367255 notable GitHub：https://github.com/notable/notable\nHBuilderX 官网：https://dcloud.io/hbuilderx.html\nMilkdown 官网：https://milkdown.dev/\nGitHub：https://github.com/Milkdown/milkdown\n果核剥壳：https://www.ghxi.com/wx20211206.html\nVS Code 插件：https://marketplace.visualstudio.com/items?itemName=mirone.milkdown\n在线体验：https://milkdown.dev/#/online-demo\n相关介绍：\nhttps://juejin.cn/post/7131641368283185182 StackEdit(网页版) 官网：https://stackedit.cn/app\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/%E8%BD%AF%E4%BB%B6/%E7%AC%94%E8%AE%B0-markdown/","title":"Markdown"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2024-01-06T13:48:21+08:00","image":"https://www.yprnet.cc/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.yprnet.cc/p/test-chinese/","title":"中文测试"},{"content":"你好，天远博客 这是天远博客的第一篇文章。\n","date":"2024-01-06T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/hello/","title":"你好"},{"content":"本文还未整理完 参考资料 GCC 环境变量 GCC相关的环境变量 LIBRARY_PATH和LD_LIBRARY_PATH环境变量的区别 有大量的环境变量可供设置以影响 GCC 编译程序的方式。利用这些变量的控制也可使用合适的命令行选项。\n一些环境变量设置在目录名列表中。这些名字和 PATH 环境变量使用的格式相同。特殊字符 PATH_SEPARATOR （安装编译程序的时候定义）用在目录名之间。在 UNIX 系统中，分隔符是冒号，而 Windows 系统中为分号。\nC_INCLUDE_PATH 编译 C 程序时使用该环境变量。该环境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定 -isystem 选项一样。会首先查找 -isystem 指定的所有目录。\n也见 CPATH 、 CPLUS_INCLUDE_PATH 和 OBJC_INCLUDE_PATH 。\nCOMPILER_PATH 该环境变量指定一个或多个目录名列表，如果没有指定 GCC_EXEC_PREFIX 定位子程序，编译程序会在此查找它的子程序。\n也见 LIBRARY_PATH 、 GCC_EXEC_PREFIX 和 -B 命令行选项。\nCPATH 编译 C 、 C++ 和 Objective-C 程序时使用该环境变量。该环境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定 -l 选项一样。会首先查找 -l 指定的所有目录。\n也见 C_INCLUDE_PATH 、 CPLUS_INCLUDE_PATH 和 OBJC_INCLUDE_PATH 。\nCPLUS_INCLUDE_PATH 编译 C++ 程序时使用该环境变量。该环境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定 -isystem 选项一样。会首先查找 -isystem 指定的所有目录。\n也见 CPATH 、 C_INCLUDE_PATH 和 OBJC_INCLUDE_PATH 。\n## DEPENDENCIES_OUTPUT 为文件名设置该环境变量会让预处理程序将基于依赖关系的 makefile 规则写入文件。不会包括系统头文件名字。\n如果环境变量设置为单名，被看作是文件名字，而依赖关系规则的名字来自源文件名字。如果定义中有两个名字，则第二个名字是用作依赖关系规则的目标名。\n设置该环境变量的结果和使用命令行选项 -MM 、 -MF 和 -MT 的组合是一样的。也见 SUNPRO_DEPENDENCIES 。\n## GCC_EXEC_PREFIX 如 果定义了该环境变量，它会作为编译程序执行的所有子程序名字的前缀。例如，如果将变量设置为 testver 而不是查找 as ，汇编器首先会在名字 testveras 下查找。如果在此没有找到，编译程序会继续根据它的普通名进行查找。可在前缀名中使用斜线指出路径名。\nGCC_EXEC_PREFIX 的默认设置为 prefix /lib/gcc-lib/ ，这里的 prefix 是安装编译程序时 configure 脚本指定的名字。该前缀也用于定位标准连接程序文件，包含进来作为可执行程序的一部分。\n如果使用 -B 命令行选项，会重写该设置。也见 COMPILER_PATH 。\nLANG 该环境变量用于指出编译程序使用的字符集，可创建宽字符文字、串文字和注释。\n定义 LANG 为 C-JIS ，指出预处理程序将多字节字符按照 JIS （日语工业标准）字符进行解释。 C-SJIS 可用来指出 Shift -JIS 字符而 C-EUCJP 指出日文 EUC 。\n如果没有定义 LANG ，或定义为不可识别，函数 mblen() 被用来确定字符宽度，而 mbtowc() 用来将多字节序列转换为宽字符。\nLC_ALL 如果设置，该环境变量的值重写 LC_MESSAGES 和 LC_CTYPE 的所有设置。\nLC_CTYPE 该 环境变量指出引用串中定义的多字节字符的字符分类。主要用于确定字符串的字符边界，字符编码需要用引号或转义符，可被错误地解释为字符串的结尾或特殊字符 串。对 Australian English ，可将它设置为 en_AU ； 对 Mexican Spanish ，可将它设置为 es_MX 。如果没有设置该变量，默认为 LANG 变量的值，或如果没有设置 LANG ，那就使用 C 英语行为。也见 LC_ALL 。\nLC_MESSAGES 该 环境变量指出编译程序使用何种语言发出诊断消息。对 Australian English ，可设置为 en_AU ； 对 Mexican Spanish ，可设置为 es_MX 。如果变量没有设置，使用 LANG 变量的默认值，或如果没有设置 LANG ，那就使用 C 英语行为。也见 LC_ALL 。\nLD_LIBRARY_PATH 该环境变量不会影响编译程序，但程序运行的时候会有影响。变量指定一个目录列表，程序会查找该列表定位共享库。只有当未在编译程序的目录中找到共享库的时候，执行程序必须设置该变量。\nLD_RUN_PATH 该环境变量不会影响编译程序，但程序运行的时候会有影响。该变量在运行时指出文件的名字，运行的程序可由此得到它的符号名字和地址。地址不会重新载入，因而可能符号引用其他文件中的绝对地址。这和 ld 工具使用 -R 选项完全一样。\nLIBRARY_PATH 该环境变量可设置为一个或多个目录名字列表，连接程序会搜寻该目录，以查找特殊连接程序文件，和由 -l （字母 l ）命令行选项指定名字的库。\n由 -L 命令行选项指定的目录在环境变量的前面，首先被查找。也见 COMPILER_PATH 。\nOBJC_INCLUDE_PATH 在编译 Objective-C 程序的时候使用该环境变量。一个或多个目录名的列表由环境变量指定，用来查找头文件，就好像在命令行中指定 -isystem 选项一样。所有由 -isystem 选项指定的目录会首先被查找。\n也见 CPATH 、 CPLUS_INCLUDE_PATH 和 C_INCLUDE_PATH 。\nSUNPRO_OUTPUT 为文件名设置该环境变量会令预处理程序将基于依赖关系的 makefile 规则写入文件。会包含系统头文件名。\n如果环境变量被设置为单个名字，它将会被当作文件名，依赖关系规则中的名字将由源文件的名字中获得。如果定义中有两个名字，第二个名字就是依赖关系规则中的目标名。\n设置该环境变量的结果与在命令行中使用参数 -M 、 -MF 和 -MT 的效果一样。参见 DEPENDENCIES_OUTPUT 。\nTMPDIR 这个变量包含了供编译程序存放临时工作文件的目录的路径名。这些文件通常在编译过程结束时被删除。这种文件的一个例子就是由预处理程序输出并输入给编译程序的文件。\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"本地编译 来源 https://github.com/niXman/mingw-builds https://gcc.gnu.org/install/configure.html yuanpeirong的GitHub仓库 https://github.com/yuanpeirong/mingw-builds 编译步骤 环境：Windows-64bit or Linux + Wine-64bit\n安装MSYS2：Install MSYS2 from: http://sourceforge.net/projects/msys2/ (MSYS2 wiki: https://www.msys2.org/wiki/MSYS2-installation/)\n把安装脚本放到以下目录（天远：可直接是下载后复制粘贴）\nGet the scripts into \u0026lt;msys root\u0026gt;/home/\u0026lt;user\u0026gt;/mingw-builds: cd \u0026amp;\u0026amp; git clone \u0026lt;paste correct url\u0026gt;\n在MSYS2环境中删除以下文件夹或重命名 In the MSYS2 file structure delete or rename the /mingw32 and /mingw64 directory.\n从环境变量中删除指向任何预安装的 MinGW 的路径 Delete the paths pointing to any preinstalled MinGW from the PATH environment variable.\n进入以下目录 Go into the MinGW-builds root directory: cd \u0026amp;\u0026amp; cd mingw-builds\n编译选项Options\n运行Run:（注意：运行前按需修改脚本）\n1 2 3 4 5 6 cd mingw-builds #天远：可直接是下载后复制粘贴，运行前按需修改脚本 git clone https://github.com/niXman/mingw-builds.git ./build --mode=gcc-13.2.0 --buildroot=/c/buildroot --jobs=4 --rev=0 --with-default-msvcrt=ucrt --rt-version=v11 --threads=posix --exceptions=seh --arch=x86_64 --bin-compress --enable-languages=c,c++,fortran 天远修改：\n1 ./build --mode=gcc-13.2.0 --buildroot=/c/buildroot --jobs=12 --rev=0 --with-default-msvcrt=ucrt --rt-version=v11 --threads=posix --exceptions=seh --arch=x86_64 --bin-compress --enable-languages=c,c++,fortran 1 2 user : cyano args : --mode=gcc-13.2.0 --arch=x86_64 --buildroot=/c/mingw64-ucrt --rt-version=v11 --rev=0 --threads=posix --exceptions=seh --with-default-msvcrt=ucrt --enable-languages=c,c++ --no-bootstrap --bin-compress --jobs=12 --logviewer-command=cat 用Github Action自动编译 可快速编译各个版本\n参考资料1 来源：https://github.com/niXman/mingw-builds/issues/666\n小龙Dev：我今天上午在 niXman 那里写了一个议题 （https://github.com/niXman/mingw-builds/issues/666），他很快就回答了，说是编译参数中默认使用了 \u0026ndash;disable-nls 参数。如果改用 \u0026ndash;enable-nls 就能支持语言本地化。\nlocalization of GCC #666\nGCC 本地化 #666\nanbangli： I use both Windows and Linux with UI language set as Chinese. I noticed that GCC\u0026rsquo;s output information is Chinese on Linux, but is English on Windows.\nIs the difference came from localization options in building?\nI hope GCC\u0026rsquo;s output information is Chinese on Windows too.\n我同时使用 Windows 和 Linux，UI 语言设置为中文。我注意到 GCC 的输出信息在 Linux 上是中文的，但在 Windows 上是英文的。\n区别是否来自建筑中的本地化选项？\n我希望 GCC 的输出信息在 Windows 上也是中文的。\nniXman： I think it is because of using \u0026ndash;disable-nls which is used by default for configuring GCC: https://github.com/niXman/mingw-builds/blob/develop/scripts/gcc-13.2.0.sh#L122\n我认为这是因为默认使用哪个来配置 GCC：https://github.com/niXman/mingw-builds/blob/develop/scripts/gcc-13.2.0.sh#L122\u0026ndash;disable-nls\n1 2 3 4 5 --enable-nls --disable-nls The --enable-nls option enables Native Language Support (NLS), which lets GCC output diagnostics in languages other than American English. Native Language Support is enabled by default if not doing a canadian cross build. The --disable-nls option disables NLS. Note that this functionality requires either libintl (provided by GNU gettext) or C standard library that contains support for gettext (such as the GNU C Library). See [–with-included-gettext](https://gcc.gnu.org/install/configure.html#with-included-gettext) for more information on the conditions required to get gettext support. 参考资料2 MinGW/GCC 编译器修改 gettext 初始化路径使之能在任意位置输出中文消息 来源：https://blog.csdn.net/hackpascal/article/details/15222083\n原文摘抄如下：\nGCC 编译器支持 gettext 的本地化，MinGW 也一样，只是可惜他们在内部实现时使用了绝对路径。这个绝对路径的前缀(prefix) 由编译时传递给 configure 的 \u0026ndash;prefix 设定，这样就导致了 MinGW 只有在指定的位置上才能实现编译消息本地化。\n我所做的就是让 GCC 在初始化 gettext 时使用相对路径，这样就能使 MinGW 在任何地方都能使用本地化的字符串了。包含文件搜索路径也同理。\n通过查找 bindtextdomain 函数可以知道 gcc 对 gettext 的初始化在 gcc\\intl.c 中完成。包含文件搜索路径定义在 incpath.c 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void gcc_init_libintl (void) { #ifdef HAVE_LC_MESSAGES setlocale (LC_CTYPE, \u0026#34;\u0026#34;); setlocale (LC_MESSAGES, \u0026#34;\u0026#34;); #else setlocale (LC_ALL, \u0026#34;\u0026#34;); #endif (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); (void) textdomain (\u0026#34;gcc\u0026#34;); /* Opening quotation mark. */ open_quote = _(\u0026#34;`\u0026#34;); /* Closing quotation mark. */ close_quote = _(\u0026#34;\u0026#39;\u0026#34;); #if defined HAVE_LANGINFO_CODESET locale_encoding = nl_langinfo (CODESET); if (locale_encoding != NULL \u0026amp;\u0026amp; (!strcasecmp (locale_encoding, \u0026#34;utf-8\u0026#34;) || !strcasecmp (locale_encoding, \u0026#34;utf8\u0026#34;))) locale_utf8 = true; #endif if (!strcmp (open_quote, \u0026#34;`\u0026#34;) \u0026amp;\u0026amp; !strcmp (close_quote, \u0026#34;\u0026#39;\u0026#34;)) { /* Untranslated quotes that it may be possible to replace with U+2018 and U+2019; but otherwise use \u0026#34;\u0026#39;\u0026#34; instead of \u0026#34;`\u0026#34; as opening quote. */ open_quote = \u0026#34;\u0026#39;\u0026#34;; #if defined HAVE_LANGINFO_CODESET if (locale_utf8) { open_quote = \u0026#34;\\xe2\\x80\\x98\u0026#34;; close_quote = \u0026#34;\\xe2\\x80\\x99\u0026#34;; } #endif } } 由于我所做的是针对 Windows 下的修改，因此所有改动都要加上 #ifdef WIN32 \u0026hellip; #endif\n首先在开头加上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #ifdef WIN32 #include \u0026lt;windows.h\u0026gt; BOOL DirectoryExists(LPSTR lpszPath) { WIN32_FIND_DATA wfd; BOOL bResult = FALSE; HANDLE hFind = FindFirstFile(lpszPath, \u0026amp;wfd); if ((hFind != INVALID_HANDLE_VALUE) \u0026amp;\u0026amp; (wfd.dwFileAttributes \u0026amp; FILE_ATTRIBUTE_DIRECTORY)) { bResult = TRUE; } FindClose(hFind); return bResult; } #endif 其中 DirectoryExists 是用来判断路径是否存在的。\n然后修改 (void) bindtextdomain (\u0026ldquo;gcc\u0026rdquo;, LOCALEDIR); 为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #ifndef WIN32 (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); #else DWORD dwSize = MAX_PATH + 20; LPSTR lpszName = (LPSTR) xmalloc(dwSize); DWORD dwRealSize = GetModuleFileNameA(NULL, lpszName, dwSize) + 1; if (dwRealSize \u0026gt; dwSize) { lpszName = (LPSTR) xrealloc(lpszName, dwSize + 20); GetModuleFileNameA(NULL, lpszName, dwRealSize + 20); } /* 去掉文件名 */ int l = strlen(lpszName); while (l \u0026gt;= 0) { if (lpszName[l] == \u0026#39;\\\\\u0026#39;) break; l--; } lpszName[l] = 0; /* 去掉一层文件夹 */ l = strlen(lpszName); while (l \u0026gt; 0) { if (lpszName[l] == \u0026#39;\\\\\u0026#39;) break; l--; } /* 判断是否到根路径 */ if (lpszName[l] != \u0026#39;\\\\\u0026#39;) (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); else { // 连接上 share\\locale lpszName[l + 1] = 0; strcat(lpszName, \u0026#34;share\\\\locale\u0026#34;); if (DirectoryExists(lpszName)) (void) bindtextdomain (\u0026#34;gcc\u0026#34;, lpszName); else (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); } free(lpszName); #endif 这样重新编译后，无论 MinGW 位置在哪，它都能显示翻译后的消息了。\ngcc-13.2.0.sh 1 2 3 4 5 6 7 PKG_VERSION=13.2.0 PKG_NAME=gcc-${PKG_VERSION} PKG_DIR_NAME=gcc-${PKG_VERSION} PKG_TYPE=.tar.xz PKG_URLS=( \u0026#34;https://ftpmirror.gnu.org/gnu/gcc/gcc-${PKG_VERSION}/gcc-${PKG_VERSION}${PKG_TYPE}\u0026#34; ) 1 2 3 4 #上述网址即 \u0026#34;https://ftpmirror.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.xz\u0026#34; #修改gcc\\intl.cc后 \u0026#34;http://www.yuanpeirong.com/gcc-13.2.0.tar.xz\u0026#34; 1 2 3 4 5 6 7 #修改前 --disable-nls #修改后 --enable-nls --with-libintl-prefix=/usr/lib --with-libintl-type=autostaticshared --with-included-gettext 其他资料 gcc编译的时候，加上 nls就支持了：nls = national language support export LC_ALL=zh_CN.UTF-8 ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"参考资料 https://doc.qt.io/qt-5/windows-building.html https://doc-snapshots.qt.io/qt5-5.15/windows-building.html https://doc.qt.io/qt-5/supported-platforms.html https://doc.qt.io/qt-5/windows.html https://doc.qt.io/qt-5/windows-requirements.html https://doc.qt.io/qt-5/configure-options.html https://wiki.qt.io/Building_Qt_5_from_Git https://wiki.qt.io/MinGW-64-bit https://blog.csdn.net/zxjohnson/article/details/106621457 (Qt 5.15.0编译指南) https://blog.csdn.net/MrTsai_cpp/article/details/115175669 (Qt 5.15的源码编译(Windows)) https://www.cnblogs.com/arxive/p/14412614.html (QT 5.15 及以后QT版本源码编译（静态库、动态库）) https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) https://blog.csdn.net/Comewood/article/details/125697120 （Windows10 Qt 遇到EGL/egl.h: No such file or directory 解决方法） 下载源码包 https://download.qt.io/archive/qt/5.15/5.15.11/single/qt-everywhere-opensource-src-5.15.11.zip 安装build工具并配置相关环境变量 D:\\Qt\\Tools\\mingw810_64\\bin These tools are not needed to run Qt 5 applications, but they are required for building Qt 5 from source. Perl - Install a recent version of perl (for instance (https://strawberryperl.com/) and add the installation location to your PATH. Python - Install Python from the here and add the installation location to your PATH. 验证build工具是否正确安装 打开cmd(不要关闭) 输入 1 2 3 4 5 set PATH=D:\\Qt\\Tools\\mingw810_64\\bin;%PATH% gcc -v g++ -v perl -V python -V 设定文件夹 F:\\Qt\\5.15.11\\src 源码目录qt-everywhere-opensource-src-5.15.11.zip解压，并改名为src，放置于F:\\Qt\\5.5.11\\src F:\\Qt\\5.15.11\\build-mingw810_64 build目录 F:\\Qt\\5.15.11-static\\mingw810_64 最后安装目录 编译 建立F:\\Qt\\qt5mingw810_64.cmd文件，需设置好Qt源代码路径、mingw810_64路径(D:\\Qt\\Tools\\mingw810_64\\bin)\n建立cmd链接cmd-qt5mingw810_64，并运行\n比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-mingw810_64 依上述定位到F:\\Qt\\5.15.11\\build-mingw810_64 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\mingw810_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource -opengl desktop -platform win32-g++ mingw32-make -j16 #开启十六线程编译，根据自己电脑实际核心数调整 mingw32-make install 编译(此段内容为历史记录，作废) 在cmd中(上述不要关闭，否则要重新set PATH=D:\\Qt\\Tools\\mingw810_64\\bin;%PATH%)\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt5mingw810_64.cmd文件，需设置好Qt源代码路径、mingw810_64路径 建立cmd链接cmd-qt5mingw810_64，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-mingw810_64 依上述定位到F:\\Qt\\5.15.11\\build-mingw810_64 依次执行命令\n1 2 3 4 #当使用上述qt5vars.cmd文件时，可省略此三行命令，因为已经在qt5vars.cmd文件中执行 SET _ROOT=F:\\Qt\\5.15.11\\src SET PATH=%_ROOT%\\qtbase\\bin;%_ROOT%\\gnuwin32\\bin;%PATH% SET _ROOT= 1 2 3 4 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\mingw810_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource -opengl desktop -platform win32-g++ mingw32-make #2023-11-23实测很慢，可改为 #mingw32-make -j16 #开启十六线程编译，根据自己电脑实际核心数调整 mingw32-make install 说明1 -static就是静态编译的意思，\n-debug-and-release，则表示将调试版、发行版都进行编译。\n-prefix 指定安装将会部署的位置，根据自己情况修改\n-nomake examples 不需要编译示例\n-nomake tests 不需要编译测试工程\n-skip qtwebengine 暂时先不编译webengine模块，因为太大了\n-opensource 开源版本\n-confirm-license 是为了自动确认开源证书，免得到时暂停手动确认\n-qt-zlib -ssl -icu 指示检测这些库，并在需要时使用\n-opengl desktop 明确指示使用你windows上安装的opengl驱动来编译程序，但这样编译出的程序在别的电脑上运行时需要目标电脑上安装的opengl驱动能兼容你的程序\n-platform win32-g++ 指明编译平台是windows，并使用mingw编译器\nFor Windows machines, either MinGW or Visual Studio toolchains can be used to compile Qt. 1 2 configure.bat -platform win32-g++ configure.bat -platform win32-msvc -opengl desktop 切换到desktop版本的opengl，解决错误提示error：EGL/egl.h: No such file or directory\n说明2 等待配置完成后(其间要输入y同意协议)，再运行命令mingw32-make mingw32-make -j16开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令mingw32-make install即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹，释放110多G的空间，它已经没用了。 2023-11-23编译(已删除) 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw810_64\\bin、需数小时更多、7.65GB\nbuild文件约16.9GB，已删除\n未编译doc\n2023-11-24编译 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw810_64\\bin、约44分钟、7.65GB 采用了qt5mingw810_64.cmd、采用了mingw32-make -j16 build文件约16.9GB，已删除 未编译doc 存档：7z(9-极限压缩） 2023-11-28编译(仅-release YPR-Desktop) 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw810_64\\bin、约15分钟、932MB 采用了qt5mingw810_64.cmd、采用了mingw32-make -j16 build文件约2.52GB，已删除 未编译doc 存档：7z(9-极限压缩） 2023-11-28编译(仅-release YPR-Server) 环境：YPR-Server、Windows 10 pro 22H2、D:\\Qt\\Tools\\mingw810_64\\bin、约1.5小时、932MB 采用了qt5mingw810_64.cmd、采用了mingw32-make -j24 build文件约2.52GB，已删除 未编译doc 存档：7z(9-极限压缩） 备注 qt-everywhere-opensource-src-5.15.11.zip用D:\\Qt\\Tools\\mingw1120_64\\bin编译，实测报错 ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"参考资料 https://doc.qt.io/qt-5/windows-building.html https://doc-snapshots.qt.io/qt5-5.15/windows-building.html https://doc.qt.io/qt-5/supported-platforms.html https://doc.qt.io/qt-5/windows.html https://doc.qt.io/qt-5/windows-requirements.html https://doc.qt.io/qt-5/configure-options.html https://wiki.qt.io/Building_Qt_5_from_Git https://wiki.qt.io/MinGW-64-bit https://blog.csdn.net/zxjohnson/article/details/106621457 (Qt 5.15.0编译指南) https://blog.csdn.net/MrTsai_cpp/article/details/115175669 (Qt 5.15的源码编译(Windows)) https://www.cnblogs.com/arxive/p/14412614.html (QT 5.15 及以后QT版本源码编译（静态库、动态库）) https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) 下载源码包 https://download.qt.io/archive/qt/5.15/5.15.11/single/qt-everywhere-opensource-src-5.15.11.zip 安装build工具并配置相关环境变量 Visual Studio 2019或2022 These tools are not needed to run Qt 5 applications, but they are required for building Qt 5 from source. Perl - Install a recent version of perl (for instance (https://strawberryperl.com/) and add the installation location to your PATH. Python - Install Python from the here and add the installation location to your PATH. 验证build工具是否正确安装 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot; 输入 1 2 Perl -V python -V 设定文件夹 F:\\Qt\\5.5.11\\src 源码目录qt-everywhere-opensource-src-5.15.11.zip解压，并改名为src，放置于F:\\Qt\\5.5.11\\src F:\\Qt\\5.5.11\\build-msvc2019_64 build目录 F:\\Qt\\5.5.11-static\\msvc2019_64 最后安装目录 编译 建立F:\\Qt\\qt5vars.cmd文件，需设置好VS2022的bat路径(x64 Native Tools Command Prompt for VS 2022)、是否amd64、Qt源代码路径\n建立cmd链接cmd-qt5vars，并运行\n本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-msvc2019_64 依上述定位到F:\\Qt\\5.15.11\\build-msvc2019_64 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\msvc2019_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource jom #按官方文档安装jom(是nmake的克隆，支持并行执行多个独立命令类似于GNU make的-j命令) jom install 编译(此段内容为历史记录，作废) 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot;\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt5vars.cmd文件，需设置好VS2022的bat路径、是否amd64、Qt源代码路径 建立cmd链接cmd-qt5vars，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-msvc2019_64 依上述定位到F:\\Qt\\5.15.11\\build-msvc2019_64 依次执行命令\n1 2 3 4 #当使用上述qt5vars.cmd文件时，可省略此三行命令，因为已经在qt5vars.cmd文件中执行 SET _ROOT=F:\\Qt\\5.15.11\\src SET PATH=%_ROOT%\\qtbase\\bin;%_ROOT%\\gnuwin32\\bin;%PATH% SET _ROOT= 1 2 3 4 5 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\msvc2019_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource nmake #2023-11-23实测较慢，可按官方文档安装jom(是nmake的克隆，支持并行执行多个独立命令类似于GNU make的-j命令)，此步改为 #jom nmake install #如上一步执行jom，此步应对应执行 #jom install 说明1 -static就是静态编译的意思， -debug-and-release，则表示将调试版、发行版都进行编译。 -prefix 指定安装将会部署的位置，根据自己情况修改 -nomake examples 不需要编译示例 -nomake tests 不需要编译测试工程 -skip qtwebengine 暂时先不编译webengine模块，因为太大了 -opensource 开源版本 -confirm-license 是为了自动确认开源证书，免得到时暂停手动确认 -qt-zlib -ssl -icu 指示检测这些库，并在需要时使用 -opengl desktop 明确指示使用你windows上安装的opengl驱动来编译程序，但这样编译出的程序在别的电脑上运行时需要目标电脑上安装的opengl驱动能兼容你的程序 -platform win32-g++ 指明编译平台是windows，并使用mingw编译器 For Windows machines, either MinGW or Visual Studio toolchains can be used to compile Qt. 1 2 configure.bat -platform win32-g++ configure.bat -platform win32-msvc 说明2 等待配置完成后(其间要输入y同意协议)，再运行命令nmake jom开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令nmake install jom install即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹。 2023-11-23编译 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约1小时、1.58GB（有部分编译错误） build文件约8.2GB，已删除 未编译doc 2023-11-24编译 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约15分钟、4.14GB 采用了qt5vars.cmd、采用了jom和jom install build文件约24GB，已删除 未编译doc 存档：7z(9-极限压缩） ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"参考资料 https://doc.qt.io/qt-6.5/windows-building.html https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) https://zhuanlan.zhihu.com/p/630112083 (QT6 opensource安装详解) 下载源码包 https://download.qt.io/archive/qt/6.5/6.5.3/single/qt-everywhere-src-6.5.3.zip 安装build工具并配置相关环境变量 D:\\Qt\\Tools\\mingw1120_64\\bin CMake\tVersion 3.16 and newer (3.17 and newer for builds 3.21 and newer for builds) Ninja Python\tVersion 3\tRequired build tool. Windows installers are available on python.org, or from the Microsoft Store. 验证build工具是否正确安装 打开cmd(不要关闭) 输入 1 2 3 4 5 6 set PATH=D:\\Qt\\Tools\\mingw1120_64\\bin;%PATH% gcc -v g++ -v cmake --version ninja --version python -V 设定文件夹 F:\\Qt\\6.5.3\\src 源码目录qt-everywhere-src-6.5.3.zip解压，并改名为src，放置于F:\\Qt\\6.5.3\\src F:\\Qt\\6.5.3\\build-mingw_64 build目录(Release版本) F:\\Qt\\6.5.3\\build-mingw_64 build目录(Debug版本) F:\\Qt\\6.5.3-static\\mingw_64 最后安装目录(Release版本) F:\\Qt\\6.5.3-static\\mingw_64d 最后安装目录(Debug版本) 编译Release版本 建立F:\\Qt\\qt6mingw_64.cmd文件，需设置好Qt源代码路径、mingw1120_64路径(D:\\Qt\\Tools\\mingw1120_64\\bin)\n建立cmd链接cmd-qt6mingw_64，并运行\n本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-mingw_64 依上述定位到F:\\Qt\\6.5.3\\build-mingw_64\n依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\mingw_64\u0026#34; -release -DNDEBUG #-DNDEBUG见常见错误 cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译Debug版本 关闭上述命令窗口，重新运行cmd链接cmd-qt6mingw_64 输入 1 2 F: cd Qt\\6.5.3\\build-mingw_64d #注意路径有d 依上述定位到F:\\Qt\\6.5.3\\build-mingw_64d 依次执行命令 1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\mingw_64d\u0026#34; -debug -DNDEBUG #注意路径有d，编译选项为-debug，-DNDEBUG见常见错误 cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译(此段内容为历史记录，作废) 在cmd中(上述不要关闭，否则要重新set PATH=D:\\Qt\\Tools\\mingw1120_64\\bin;%PATH%)\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt6mingw_64.cmd文件，需设置好Qt源代码路径、mingw1120_64路径 建立cmd链接cmd-qt6mingw_64，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-mingw_64 依上述定位到F:\\Qt\\6.5.3\\build-mingw_64\n依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\mingw_64\u0026#34; -debug-and-release -DNDEBUG #见常见错误 cmake --build . #不要忘记点 cmake --install . #不要忘记点 说明 其中-static就是静态编译的意思，而后面的-debug-and-release，则表示将调试版、发行版都进行编译。 等待配置完成后，再运行命令cmake \u0026ndash;build .开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令cmake \u0026ndash;install .即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹，释放110多G的空间，它已经没用了。 常见错误 ERROR: Exactly one of NDEBUG and _DEBUG needs to be defined 在configure.bat这个命令中，增加-DNDEBUG 1 E:\\qt-everywhere-src-6.5.0\\qtbase\\configure.bat -top-level -release -no-pch -prefix \u0026#34;E:\\Qt\\Qt6.5.0\u0026#34; -skip qtwebengine -nomake tools -nomake tests -nomake examples -DNDEBUG 2023-11-23编译(已删除) 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw1120_64\\bin、约20分钟、2.0GB build文件夹约100多GB，已删除 测试时程序无法Debug：带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 2023-11-25编译 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw1120_64\\bin、约15分钟(单独Release或Debug)、Release1.96GB+Debug37.9GB 采用了cmd-qt6mingw_64，分别编译Release和Debug版本 build文件夹：Release55.8GB+Debug120GB，已删除 存档：7z(9-极限压缩） ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"参考资料 https://doc.qt.io/qt-6.5/windows-building.html https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) 下载源码包 https://download.qt.io/archive/qt/6.5/6.5.3/single/qt-everywhere-src-6.5.3.zip 安装build工具并配置相关环境变量 Visual Studio 2019或2022 CMake\tVersion 3.16 and newer (3.17 and newer for builds 3.21 and newer for builds) Ninja Python\tVersion 3\tRequired build tool. Windows installers are available on python.org, or from the Microsoft Store. 验证build工具是否正确安装 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot; 输入 1 2 3 cmake --version ninja --version python -V 设定文件夹 F:\\Qt\\6.5.3\\src 源码目录qt-everywhere-src-6.5.3.zip解压，并改名为src，放置于F:\\Qt\\6.5.3\\src F:\\Qt\\6.5.3\\build-msvc2019_64 build目录(Release版本) F:\\Qt\\6.5.3\\build-msvc2019_64d build目录(Debug版本) F:\\Qt\\6.5.3-static\\msvc2019_64 最后安装目录(Release版本) F:\\Qt\\6.5.3-static\\msvc2019_64d 最后安装目录(Debug版本) 编译Release版本 建立F:\\Qt\\qt6vars.cmd文件，需设置好VS2022的bat路径(x64 Native Tools Command Prompt for VS 2022)、是否amd64、Qt源代码路径\n建立cmd链接cmd-qt6vars，并运行\n本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-msvc2019_64 依上述定位到F:\\Qt\\6.5.3\\build-msvc2019_64 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64\u0026#34; -release cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译Debug版本 关闭上述命令窗口，重新运行cmd链接cmd-qt6vars\n输入\n1 2 F: cd Qt\\6.5.3\\build-msvc2019_64d #注意路径有d 依上述定位到F:\\Qt\\6.5.3\\build-msvc2019_64d 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64d\u0026#34; -debug #注意路径有d，编译选项为-debug cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译(此段内容为历史记录，作废) 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot;\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt6vars.cmd文件，需设置好VS2022的bat路径、是否amd64、Qt源代码路径 建立cmd链接cmd-qt6vars，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-msvc2019_64 依上述定位到F:\\Qt\\6.5.3\\build-msvc2019_64 依次执行命令\n1 2 3 4 #2023-11-23编译、2023-11-24编译 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64\u0026#34; -debug-and-release cmake --build . #不要忘记点 cmake --install . #不要忘记点 2023-11-24编译解决带d版本在camke \u0026ndash;install .时没有被复制过来\n清空build目录，最后安装目录不动\n依次执行命令\n1 2 3 4 #重新用-debug编译一次 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64\u0026#34; -debug cmake --build . #不要忘记点 cmake --install . #不要忘记点 说明 其中-static就是静态编译的意思，而后面的-debug-and-release，则表示将调试版、发行版都进行编译。 等待配置完成后，再运行命令cmake \u0026ndash;build .开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令cmake \u0026ndash;install .即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹，释放110多G的空间，它已经没用了。 2023-11-23编译(已删除) 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约20分钟、1.41GB build文件夹约100多GB，已删除 测试时程序无法Debug：带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 2023-11-24编译 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约20分钟、Release1.41GB+Debug15.6GB 采用了qt6vars.cmd build文件夹约111GB（单独Release为51.3GB，单独Debug为77.9GB），已删除 测试时程序无法Debug：带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 解决方案：用-debug选项再编译一次（build文件夹需清空，install文件夹需备份Release版本） -debug和\u0026ndash;release选项有同名文件但大小不同，install文件夹不能合并 Debug版本QTDIR路径不是F:\\Qt\\6.5.3\\build-msvc2019_64d而是F:\\Qt\\6.5.3\\build-msvc2019_64，应用qt.conf修正 存档：7z(9-极限压缩） ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"Qt6-静态库测试 Qt6.5.3-static-mingw1120_64-Release（袁培荣编译2023-11-25） Release：正常 Debug： 正常 Qt6.5.3-static-mingw1120_64-Debug（袁培荣编译2023-11-25） Release：正常 Debug： exe文件有713MB Qt6.5.3-static-msvc2019_64-Release（袁培荣编译2023-11-24） Release：正常 Debug： error: dependent \u0026lsquo;F:\\Qt\\6.5.3-static\\msvc2019_64\\lib\\Qt6Widgetsd.lib\u0026rsquo; does not exist. Qt6.5.3-static-msvc2019_64-Debug（袁培荣编译2023-11-24） Release：error: dependent \u0026lsquo;F:\\Qt\\6.5.3-static\\msvc2019_64d\\lib\\Qt6Widgets.lib\u0026rsquo; does not exist. Debug：正常 Qt6.5.3-static-mingw1120_64（袁培荣编译2023-11-23） Release：正常 Debug： error: No rule to make target \u0026lsquo;F:/Qt/6.5.3-static/mingw_64/lib/libQt6Widgetsd.a\u0026rsquo;, needed by \u0026lsquo;debug/samp2_2.exe\u0026rsquo;. Stop. 原因为带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 解决方案：用-debug选项再编译一次 Qt6.5.3-static-msvc2019_64（袁培荣编译2023-11-23） Release：正常 Debug：error: dependent \u0026lsquo;F:\\Qt\\6.5.3-static\\msvc2019_64\\lib\\Qt6Widgetsd.lib\u0026rsquo; does not exist. 原因为带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 解决方案：用-debug选项再编译一次 Qt6.5.2-static-mingw1320_64（MSYS2-UCRT64） Release： error: cannot find -lb2: No such file or directory error: collect2.exe: error: ld returned 1 exit status error: [Makefile.Release:74: release/Test.exe] Error 1 也报过77 Debug：同上 Qt5-静态库测试 Qt5.15.11-static-mingw810_64（袁培荣编译2023-11-24） Release：正常 Debug：exe文件有691MB（是-debug-and-release的原因，如果只-release可解决问题） Qt5.15.11-static-mingw810_64-Release（袁培荣编译2023-11-28 YPR-Desktop） Release：正常 Debug：正常 Qt5.15.11-static-mingw810_64-Release（袁培荣编译2023-11-28 YPR-Server） Release：正常 Debug：正常 Qt5.15.11-static-msvc2019_64（袁培荣编译2023-11-24） Release：exe文件大小正常\nDebug：exe文件大小正常\n两种模式都有以下问题\nwarning: C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失 error: C2001: 常量中有换行符 error: C2146: 语法错误: 缺少“)”(在标识符“ui”的前面) 解决方案在pro文件中加入QMAKE_CXXFLAGS += /utf-8，参考资料：彻底解决Qt中文乱码以及汉字编码的问题(UTF-8/GBK)\nQt5.15.10-static-mingw1320_64（MSYS2-UCRT64） Release：正常\nDbug：正常\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"qt.conf和主题 qt.conf 加参数 -platform windows:fontenging=freetype:darkmode=2\n或者 qt.conf\n1 2 [Platforms] WindowsArguments = fontengine=freetype,darkmode=2 1 2 [Platforms] WindowsArguments = darkmode=2,fontengine=freetype 不用qt.conf，小熊猫的标题栏颜色不能与Windows颜色设置统一\n主题 墨落的英文名主要是考虑到表意，作为自带主题，其他几个主题名字都是表意的，突然插一个 MoLo 会把其他语言的用户搞懵，“Inky Dark” 是兼顾表意和原文的选择；配色 MoLo CodeBlack -\u0026gt; Inky Code 也基于同样的逻辑。\n跟随系统是 2023 年夏给 KDE/DDE 做的，macOS 上效果也还可以，但因为 Windows 的效果过于吓人，当时不得不刻意禁用了，加入 Lua 插件之后有了一个新的选择：给 Windows 做一个低配版，通过把平台差异从主程序转移到插件里，降低维护难度。这才是完整版的 “跟随系统样式和颜色” 主题：\nP.S. 因为现在 Windows 平台 qt.conf 的改动，这个主题的效果可能会带来一点误解。它在 Windows 上的效果是：系统配色是浅色，就是浅色主题；系统配色是深色，就是深色主题。\n随机浅色就是真的随机，每次加载主题都会在浅色主题的调色板随机叠加一层比较淡的色彩（叠加的色彩浓度我专门测试过，不会和高亮撞上的）。这个如果不喜欢那不用它就是了，没必要删掉吧。至于 “用户可以控制的浅色”，没有必要再去刻意实现了，过一段时间插件接口基本稳定了开放出来，自己拿 random_light.lua 改一个就行（把 hue 参数从随机生成改成固定值）。\n完整版（KDE/DDE/LXQt 和 macOS）是任意彩色，在第一次打开的界面保留很有必要，选这个界面可以和系统 UI 融为一体。Windows 是低配版，“不太难看” 且不用再维护平台差异。\n集成到主程序的主要问题是预览功能不好做。小熊猫内部每个编辑器是独立的 instance，可以有自己的配色方案，所以设置界面插一个编辑器进去就能预览。Qt 的样式和配色是全局的，要单独在某些控件上预览很难。\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"源代码：https://github.com/CyanoHao/RedPanda-CPP/tree/compiler-hint/platform/windows/utf8 编译参数：https://github.com/CyanoHao/RedPanda-CPP/blob/compiler-hint/packages/msys/domain/build.sh#L144\n标准输入输出不乱码是 utf8init.o 起作用，utf8manifest.o 只影响调用系统 API（如打开文件之类操作）。因此这种方法在老版本系统也能一定程度上起作用，至少对于初学者问题不大。\nWindows 10 v1903 及以上：完全支持 UTF-8 Windows 10 v1809：标准输入输出支持 UTF-8（系统不支持 manifest 但可以用 OpenConsole） 早期版本：标准输出支持 UTF-8，只能输入 ASCII 范围内的字符（系统不支持 manifest 也不能用 OpenConsole）\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"Windows 内建支持 Windows 内建支持的终端：conhost，wt（Windows Terminal），alacritty，konsole（试运行会报错，但实际上能用），mintty（Git / MSYS2 带的终端）\n1 2 $argv powershell.exe -c \u0026#34;echo hello; sleep 3\u0026#34; ConEmu ConEmu 还没加进去，参数模式手动填： $term -run $argv\ncmder cmder 暂时无解，参数过于反人类。\ncmder 是对 comenu 的包装，它有一个选项 /x，用来转发参数给 conemu。\n但它转发参数的行为是：先拼好调用 conemu 的 lpCommandLine，然后把 /x 后面的一个参数追加到 lpCommandLine，再调 CreateProcessW。\n而 conemu 直接执行程序的参数是这样的（argv 数组以 json 形式表示）\n1 2 3 4 5 6 7 [ \u0026#34;conemu64.exe\u0026#34;, \u0026#34;-run\u0026#34;, \u0026#34;powershell\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo hello; sleep 3\u0026#34; ] 于是小熊猫必须这样调 cmder（argv 数组以 json 形式表示）\n1 2 3 4 5 [ \u0026#34;cmder.exe\u0026#34;, \u0026#34;/x\u0026#34;, \u0026#34;-run powershell -c \\\u0026#34;echo hello; sleep 3\\\u0026#34;\u0026#34; ] 确实是反人类了\nLinux 1 2 3 终端：konsole 参数模式：$term -e $argv 命令行预览：konsole -e -sh -c \u0026#34;echo;sleep 3\u0026#34; 其他 那个 defaultShell 是拿来测试终端用的。因为 sh -c \u0026ldquo;echo hello; sleep 3\u0026rdquo; 行为足够简单，但命令行又复杂到能暴露很多参数错误问题。 小熊猫运行程序是直接调用 consolepauser，并不关心 shell 是什么。\n命令解释器：cmd.exe 、powershell.exe、pwsh.exe 。 终端模拟器：conhost.exe、Windows Terminal、一堆第三方的模拟器，如ConEmu等。前者用于解析输入的命令并执行该命令，但没有创建窗口的能力。后者用于更方便地与命令行程序进行交互。\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"官网 https://www.msys2.org/ 换源 1 sed -i \u0026#34;s#https\\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g\u0026#34; /etc/pacman.d/mirrorlist* 清华源帮助：https://mirror.tuna.tsinghua.edu.cn/help/msys2/ MSYS2中MINGW_PACKAGE_PREFIX对应关系 参考：https://www.msys2.org/docs/package-naming/ 参考：https://www.msys2.org/docs/environments/ Name MINGW_PACKAGE_PREFIX MSYS None MINGW64 mingw-w64-x86_64- UCRT64 mingw-w64-ucrt-x86_64- CLANG64 mingw-w64-clang-x86_64- MINGW32 mingw-w64-i686- CLANG32 mingw-w64-clang-i686- CLANGARM64 mingw-w64-clang-aarch64- 安装记录 安装工具链 pacman -S mingw-w64-x86_64-toolchain //YPR-Sever已安装 pacman -S mingw-w64-ucrt-x86_64-toolchain //YPR-Sever已安装 YPR-Desktop已安装 pacman -S mingw-w64-clang-x86_64-toolchain //YPR-Sever已安装 pacman -S mingw-w64-i686-toolchain pacman -S mingw-w64-clang-i686-toolchain pacman -S mingw-w64-clang-aarch64-toolchain pacman -S $MINGW_PACKAGE_PREFIX-toolchain 安装Qt5库 pacman -S mingw-w64-x86_64-qt5-static //YPR-Sever已安装 YPR-Desktop已安装 pacman -S mingw-w64-ucrt-x86_64-qt5-static //YPR-Sever已安装 YPR-Desktop已安装 pacman -S mingw-w64-clang-x86_64-qt5-static //YPR-Sever已安装 YPR-Desktop已安装 pacman -S mingw-w64-i686-qt5-static pacman -S mingw-w64-clang-i686-qt5-static pacman -S mingw-w64-clang-aarch64-qt5-stat pacman -S $MINGW_PACKAGE_PREFIX-qt5-static 安装Qt6库 pacman -S mingw-w64-ucrt-x86_64-qt6-static //YPR-Desktop已安装 仅安装编译工具 pacman -S mingw-w64-ucrt-x86_64-gcc //MinGW64 ucrt pacman -S mingw-w64-x86_64-gcc //MinGW64 msvcrt pacman -S mingw-w64-i686-gcc //MinGW32 msvcrt pacman -S mingw-w64-clang-x86_64-gcc //clang64 pacman -S mingw-w64-clang-i686-gcc //clang32 安装make pacman -S mingw-w64-ucrt-x86_64-make pacman -S mingw-w64-clang-x86_64-make 安装GDB pacman -S mingw-w64-ucrt-x86_64-gdb pacman -S mingw-w64-clang-x86_64-lldb 仅MSYS2环境下的工具安装 pacman -S binutils //二进制工具集 //YPR-Desktop已安装 pacman -S gcc //GNU编译器集合-C和C++前端 //YPR-Desktop已安装 pacman -S gcc-libs //GCC提供的运行时库 pacman -S gdb //GNU调试器 //YPR-Desktop已安装 pacman -S gettext //GNU国际化库 //YPR-Desktop已安装 pacman -S gettext-devel //GNU国际化开发实用程序 //YPR-Desktop已安装 pacman -S make //make工具 //YPR-Desktop已安装\n安装其他 pacman -S base //Minimal package set to define a basic MSYS2 installation pacman -S base-devel //Minimal package set for building packages with makepkg pacman -S vim pacman -S yasm pacman -S nasm 备注 MSYS2中有两种工具链：\n一种是原生GCC，其编译的是UNIX代码，运行依赖msys2xxx.dll； 一种是mingw工具链，用于编译windows代码（能调用windows API，不能调用unix系统调用）的， 生成exe，运行时只依赖windows系统的dll。 更新和维护MSYS2 参考：https://www.msys2.org/docs/updating/ 通过安装程序或其他方式安装 MSYS2 后，您需要继续使用内置工具对其进行更新。MSYS2 是一个滚动发布发行版，仅支持完整的系统升级，这意味着各种软件包经常进行次要和主要更新，并且您只能一次更新所有软件包。 若要更新所有包，请运行以下命令：\n1 2 3 4 5 6 7 8 9 10 11 12 $ pacman -Suy :: Synchronizing package databases... mingw32 is up to date mingw64 is up to date ucrt64 is up to date clang32 is up to date clang64 is up to date msys is up to date :: Starting core system upgrade... there is nothing to do :: Starting full system upgrade... there is nothing to do 在某些情况下，某些核心软件包会被更新，pacman 会提示你关闭所有终端：\n1 2 :: To complete this update all MSYS2 processes including this terminal will be closed. Confirm to proceed [Y/n] 确认后，您需要启动一个新终端并再次运行更新，以更新剩余的非核心包。pacman -Suy\n其他命令参考 1. 安装软件 pacman -S 软件名: 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -S \u0026ndash;needed 软件名1 软件名2: 安装软件，但不重新安装已经是最新的软件。 pacman -Sy 软件名：安装软件前，先从远程仓库下载软件包数据库(数据库即所有软件列表)。 pacman -Sv 软件名：在显示一些操作信息后执行安装。 pacman -Sw 软件名: 只下载软件包，不安装。 pacman -U 软件名.pkg.tar.gz：安装本地软件包。 pacman -U http://www.example.com/repo/example.pkg.tar.xz : 安装一个远程包（不在 pacman 配置的源里面）。 2. 更新系统 pacman -Sy: 从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。 pacman -Su: 升级所有已安装的软件包。 3. 卸载软件 pacman -R 软件名: 该命令将只删除包，保留其全部已经安装的依赖关系 pacman -Rv 软件名: 删除软件，并显示详细的信息 pacman -Rs 软件名: 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Rsc 软件名: 删除软件，并删除所有依赖这个软件的程序，慎用 pacman -Ru 软件名: 删除软件,同时删除不再被任何软件所需要的依赖 4. 搜索软件 pacman -Ss 关键字: 在仓库中搜索含关键字的软件包（本地已安装的会标记） pacman -Sl :显示软件仓库中所有软件的列表。可以省略，通常这样用:pacman -Sl | 关键字 pacman -Qs 关键字: 搜索已安装的软件包 pacman -Qu: 列出所有可升级的软件包 pacman -Qt: 列出不被任何软件要求的软件包 查看软件信息\npacman -Q 软件名: 查看软件包是否已安装，已安装则显示软件包名称和版本 pacman -Qi 软件名: 查看某个软件包信息，显示较为详细的信息，包括描述、构架、依赖、大小等等 pacman -Ql 软件名: 列出软件包内所有文件，包括软件安装的每个文件、文件夹的名称和路径 5. 软件包组 pacman -Sg: 列出软件仓库上所有的软件包组 pacman -Qg: 列出本地已经安装的软件包组和子包 pacman -Sg 软件包组: 查看某软件包组所包含的所有软件包 pacman -Qg 软件包组: 和pacman -Sg 软件包组完全一样\n6. 清除缓存 pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。\npacman -Scc：清理所有的缓存文件。\npacman 安装包缓存位置及清理\n如果进行系统更新时,磁盘不足,清理软件安装包缓存是一种可行的方案.\npacman 会将自己下载的软件压缩包保存在 /var/cache/pacman/pkg/目录下,\n默认情况下并不会删除安装包,即便软件已经卸载.\n下面提供几个清理程度不同的命令.\npaccache -r # 清理缓存,仅包含最近的三个版本\npaccache -rk1 # 清理缓存,仅包含最近的1个版本\npacman -Sc # 清理未安装软件包\npacman -Scc # 清理缓存中所有内容\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"参考资料 GCC本地化-Linux 注意 本文是指MSYS2主环境中的gcc，不是指mingw64、mingw64、mingw32子环境 缺点是：即便静态链接，生成的exe程序还是需要msys-2.0.dll MSYS2主环境 安装 1 2 3 4 pacman -S gcc //GNU编译器集合-C和C++前端 pacman -S gcc-libs //GCC提供的运行时库 我不确定是否必需 pacman -S gettext //GNU国际化库 pacman -S gettext-devel //GNU国际化开发实用程序 我不确定是否必需 \u0026ldquo;D:\\msys64\\home\\YuanPeirong.bashrc\u0026quot;加入 1 2 export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LANGUAGE=\u0026#34;zh_CN.UTF-8\u0026#34; gcc.mo\ngcc版本为13\n确保有\u0026quot;D:\\msys64\\usr\\share\\locale\\zh_CN\\LC_MESSAGES\\gcc.mo\u0026rdquo;\n外部使用\n方法1：设置系统环境变量\n变量名：LANG 变量值：zh_CN.UTF-8\n变量名：LANGUAGE 变量值：zh_CN.UTF-8\n方法2：在bat文件中写入以下变量，再启动其他外部工具\n1 2 set LANG=zh_CN.UTF-8 set LANGUAGE=zh_CN.UTF-8 方法3：写个exe文件设置变量，再调用真正要使用的外部工具（未测试）\n方法4：写个run.ps1脚本（未测试）\n方法5：设置临时变量，用分号执行多条命令，如：\nexport LANG=\u0026quot;zh_CN.UTF-8\u0026quot;;export LANGUAGE=\u0026quot;zh_CN.UTF-8\u0026quot;;gcc -v\nexport LANG=\u0026quot;zh_CN.utf8\u0026quot;;export LANGUAGE=\u0026quot;zh_CN.utf8\u0026quot;;gcc -v\n以上两条命令都有效。\nzh_CN.UTF-8和zh_CN.utf8是等效的\n但gcc源码的文档中是用zh_CN.utf8描述的\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"Group: mingw-w64-ucrt-x86_64-toolchain https://packages.msys2.org/groups/mingw-w64-ucrt-x86_64-toolchain 安装: pacman -S mingw-w64-ucrt-x86_64-toolchain 下载：pacman -Sw mingw-w64-ucrt-x86_64-toolchain (D:\\msys64\\var\\cache\\pacman\\pkg) Packages:\nmingw-w64-ucrt-x86_64-binutils mingw-w64-ucrt-x86_64-crt-git mingw-w64-ucrt-x86_64-gcc mingw-w64-ucrt-x86_64-gcc-ada mingw-w64-ucrt-x86_64-gcc-fortran mingw-w64-ucrt-x86_64-gcc-libgfortran mingw-w64-ucrt-x86_64-gcc-libs mingw-w64-ucrt-x86_64-gcc-objc mingw-w64-ucrt-x86_64-libgccjit mingw-w64-ucrt-x86_64-gdb mingw-w64-ucrt-x86_64-gdb-multiarch mingw-w64-ucrt-x86_64-headers-git mingw-w64-ucrt-x86_64-libmangle-git mingw-w64-ucrt-x86_64-libwinpthread-git mingw-w64-ucrt-x86_64-winpthreads-git mingw-w64-ucrt-x86_64-make mingw-w64-ucrt-x86_64-pkgconf mingw-w64-ucrt-x86_64-tools-git mingw-w64-ucrt-x86_64-winstorecompat-git Group: mingw-w64-x86_64-toolchain https://packages.msys2.org/groups/mingw-w64-x86_64-toolchain 安装：pacman -S mingw-w64-x86_64-toolchain 下载：pacman -Sw mingw-w64-x86_64-toolchain Packages:\nmingw-w64-x86_64-binutils //二进制工具集 mingw-w64-x86_64-crt-git //适用于Windows的MinGW-w64 CRT mingw-w64-x86_64-gcc //GNU编译器集合-C和C++语言 mingw-w64-x86_64-gcc-ada //GNU编译器集合-ada语言 mingw-w64-x86_64-gcc-fortran //GNU编译器集合-fortran语言 mingw-w64-x86_64-gcc-libgfortran ///GNU编译器集合-libgfortran mingw-w64-x86_64-gcc-libs //GNU编译器集合-库 mingw-w64-x86_64-gcc-objc //GNU编译器集合ObjC,Obj-C++语言 mingw-w64-x86_64-libgccjit //GNU编译器集合-libgccjit mingw-w64-x86_64-gdb //GNU调试器 mingw-w64-x86_64-gdb-multiarch //GNU调试器(支持所有目标) mingw-w64-x86_64-headers-git //头文件 mingw-w64-x86_64-libmangle-git //库 mingw-w64-x86_64-libwinpthread-git //winpthreads库 mingw-w64-x86_64-winpthreads-git //winpthreads库 mingw-w64-x86_64-make //make工具 mingw-w64-x86_64-pkgconf //pkg-config兼容实用程序,不依赖于 glib mingw-w64-x86_64-tools-git //工具 mingw-w64-x86_64-winstorecompat-git //winRT兼容库 Group: mingw-w64-clang-x86_64-toolchain https://packages.msys2.org/groups/mingw-w64-clang-x86_64-toolchain 安装：pacman -S mingw-w64-clang-x86_64-toolchain 下载：pacman -Sw mingw-w64-clang-x86_64-toolchain\nmingw-w64-clang-x86_64-clang mingw-w64-clang-x86_64-clang-analyzer mingw-w64-clang-x86_64-clang-libs mingw-w64-clang-x86_64-clang-tools-extra mingw-w64-clang-x86_64-compiler-rt mingw-w64-clang-x86_64-gcc-compat mingw-w64-clang-x86_64-lld mingw-w64-clang-x86_64-llvm mingw-w64-clang-x86_64-llvm-libs mingw-w64-clang-x86_64-crt-git mingw-w64-clang-x86_64-headers-git mingw-w64-clang-x86_64-libc++ mingw-w64-clang-x86_64-libunwind mingw-w64-clang-x86_64-libmangle-git mingw-w64-clang-x86_64-libwinpthread-git mingw-w64-clang-x86_64-winpthreads-git mingw-w64-clang-x86_64-lldb mingw-w64-clang-x86_64-make mingw-w64-clang-x86_64-openmp mingw-w64-clang-x86_64-pkgconf mingw-w64-clang-x86_64-polly mingw-w64-clang-x86_64-tools-git mingw-w64-clang-x86_64-winstorecompat-git Group: mingw-w64-i686-toolchain https://packages.msys2.org/groups/mingw-w64-i686-toolchain 安装：pacman -S mingw-w64-i686-toolchain 下载：pacman -Sw mingw-w64-i686-toolchain Packages:\nmingw-w64-i686-binutils mingw-w64-i686-crt-git mingw-w64-i686-gcc mingw-w64-i686-gcc-ada mingw-w64-i686-gcc-fortran mingw-w64-i686-gcc-libgfortran mingw-w64-i686-gcc-libs mingw-w64-i686-gcc-objc mingw-w64-i686-libgccjit mingw-w64-i686-gdb mingw-w64-i686-gdb-multiarch mingw-w64-i686-headers-git mingw-w64-i686-libmangle-git mingw-w64-i686-libwinpthread-git mingw-w64-i686-winpthreads-git mingw-w64-i686-make mingw-w64-i686-pkgconf mingw-w64-i686-tools-git mingw-w64-i686-winstorecompat-git Group: mingw-w64-clang-i686-toolchain https://packages.msys2.org/groups/mingw-w64-clang-i686-toolchain 安装：pacman -S mingw-w64-clang-i686-toolchain 下载：pacman -Sw mingw-w64-clang-i686-toolchain Packages:\nmingw-w64-clang-i686-clang mingw-w64-clang-i686-clang-analyzer mingw-w64-clang-i686-clang-libs mingw-w64-clang-i686-clang-tools-extra mingw-w64-clang-i686-compiler-rt mingw-w64-clang-i686-gcc-compat mingw-w64-clang-i686-lld mingw-w64-clang-i686-llvm mingw-w64-clang-i686-llvm-libs mingw-w64-clang-i686-crt-git mingw-w64-clang-i686-headers-git mingw-w64-clang-i686-libc++ mingw-w64-clang-i686-libunwind mingw-w64-clang-i686-libmangle-git mingw-w64-clang-i686-libwinpthread-git mingw-w64-clang-i686-winpthreads-git mingw-w64-clang-i686-lldb mingw-w64-clang-i686-make mingw-w64-clang-i686-openmp mingw-w64-clang-i686-pkgconf mingw-w64-clang-i686-polly mingw-w64-clang-i686-tools-git mingw-w64-clang-i686-winstorecompat-git Group: mingw-w64-clang-aarch64-toolchain https://packages.msys2.org/groups/mingw-w64-clang-aarch64-toolchain Installation: pacman -S mingw-w64-clang-aarch64-toolchain Packages:\nmingw-w64-clang-aarch64-clang mingw-w64-clang-aarch64-clang-analyzer mingw-w64-clang-aarch64-clang-libs mingw-w64-clang-aarch64-clang-tools-extra mingw-w64-clang-aarch64-compiler-rt mingw-w64-clang-aarch64-gcc-compat mingw-w64-clang-aarch64-lld mingw-w64-clang-aarch64-llvm mingw-w64-clang-aarch64-llvm-libs mingw-w64-clang-aarch64-crt-git mingw-w64-clang-aarch64-headers-git mingw-w64-clang-aarch64-libc++ mingw-w64-clang-aarch64-libunwind mingw-w64-clang-aarch64-libmangle-git mingw-w64-clang-aarch64-libwinpthread-git mingw-w64-clang-aarch64-winpthreads-git mingw-w64-clang-aarch64-lldb mingw-w64-clang-aarch64-make mingw-w64-clang-aarch64-openmp mingw-w64-clang-aarch64-pkgconf mingw-w64-clang-aarch64-polly mingw-w64-clang-aarch64-tools-git mingw-w64-clang-aarch64-winstorecompat-git ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"平台：ThinkBook 16P Winodws 10 版本：\n1 2 3 #wsl -l -v NAME STATE VERSION * Ubuntu-22.04 Stopped 2 清华源 root用户密码 安装GUI应用 sudo apt install nautilus (GNOME桌面的文件管理器) sudo apt install gcc sudo apt install g++ sudo apt install gdb sudo apt install make sudo apt install gettext sudo apt install gcc-11-locales sudo apt install language-pack-zh-hans （建议在安装gcc前安装） 设置/etc/locale.gen为中文 设置root和yuanpeirong用户的.bashrc为中文 将/usr/share/locale-langpack/zh_CN/LC_MESSAGES/gcc.mo复制到/usr/share/locale/zh_CN/LC_MESSAGES/，并改名为gcc-11.mo 平台：ThinkPad T480 Winodws 10 版本：#wsl -l -v NAME STATE VERSION\nUbuntu-22.04 Stopped 2 1、清华源 2、root用户密码 3、安装GUI应用 sudo apt install gnome-text-editor y (Gnome 文本编辑器) sudo apt install vlc -y (播放器) 4、安装gcc、g++、gdb\n平台：YPR-Server Winodws 10 版本：#wsl -l -v NAME STATE VERSION\nUbuntu-22.04 Stopped 2 1、清华源 2、root用户密码 3、安装GUI应用 sudo apt install gnome-text-editor y (Gnome 文本编辑器) 4、安装gcc、g++、gdb ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"官网 https://www.syntevo.com/smartgit/ 注册非商业许可证 https://www.syntevo.com/cn/smartgit/register-non-commercial/ 非商业许可证已申请记录 yuanpeirong yuanpeirong@outlook.com 已成功 yuanpeirong yuanpeirong@vip.qq.com yuanpeirong yuanpeirong@live.cn yuanpeirong yuanpeirong@live.com ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"相关网址 官网：https://code.visualstudio.com/\n文档：https://code.visualstudio.com/docs\n变量参考 来源：https://code.visualstudio.com/docs/editor/variables-reference\n预定义变量 支持以下预定义变量：\n${userHome} - 用户主文件夹的路径 ${workspaceFolder} - 在 VS Code 中打开的文件夹的路径 ${workspaceFolderBasename} - 在 VS Code 中打开的文件夹的名称，不带任何斜杠 （/） ${file} - 当前打开的文件 ${fileWorkspaceFolder} - 当前打开的文件的工作区文件夹 ${relativeFile} - 当前打开的文件相对于workspaceFolder ${relativeFileDirname} - 当前打开的文件的目录名相对于workspaceFolder ${fileBasename} - 当前打开的文件的基名 ${fileBasenameNoExtension} - 当前打开的文件的 basename，没有文件扩展名 ${fileExtname} - 当前打开的文件的扩展名 ${fileDirname} - 当前打开的文件的文件夹路径 ${fileDirnameBasename} - 当前打开的文件的文件夹名称 ${cwd} - VS Code 启动时任务运行程序的当前工作目录 ${lineNumber} - 活动文件中当前选定的行号 ${selectedText} - 活动文件中当前选定的文本 ${execPath} - 正在运行的 VS Code 可执行文件的路径 ${defaultBuildTask} - 默认构建任务的名称 ${pathSeparator} - 操作系统用于分隔文件路径中组件的字符 预定义变量示例 假设您有以下要求： 位于编辑器中打开的文件;/home/your-username/your-project/folder/file.ext 作为根工作区打开的目录。/home/your-username/your-project 因此，每个变量将具有以下值：\n${userHome} - /home/your-username ${workspaceFolder} - /home/your-username/your-project ${workspaceFolderBasename} - your-project ${文件} - /home/your-username/your-project/folder/file.ext ${fileWorkspaceFolder} - /home/your-username/your-project ${relativeFile} - folder/file.ext ${relativeFileDirname} - folder ${fileBasename} - file.ext ${fileBasenameNoExtension} - file ${fileDirname} - /home/your-username/your-project/folder ${fileExtname} - .ext ${lineNumber} - 游标的行号 ${selectedText} - 在代码编辑器中选择的文本 ${execPath} - Code.exe 的位置 ${pathSeparator} - 在 macOS 或 linux 上，在 Windows 上/\n提示：在字符串值中使用 IntelliSense，以获取预定义变量的完整列表。tasks.jsonlaunch.json 参考资料 C++相关 在vscode配置C++环境(clang编译器) 傻瓜式配置向导 - nikiss - 博客园 https://www.cnblogs.com/nikiss/p/14208341.html vscode+clang+llvm 搭建 C++ 编译环境（windows） - 知乎 https://zhuanlan.zhihu.com/p/613922486\" 配置 C++: LLVM (Clang + Clangd + LLDB) v2.1.0 文档 https://windowsmacos-vscode-c-llvm-clang-clangd-lldb.readthedocs.io/index.html 使用 WSL 在 VScode上用 LLVM + Clangd + LLDB高效编程 C++_wsl 安装codelldb_海涛的学习笔记的博客-CSDN博客 https://blog.csdn.net/qq_25534975/article/details/121931415\" vscode C++ debug: lldb: unrecognized option `\u0026ndash;interpreter=mi_lldb \u0026ndash;interpreter_旧人赋荒年的博客-CSDN博客 https://blog.csdn.net/yangziluomu/article/details/100037876\" vscode使用lldb调试C++程序_vscode lldb-CSDN博客 https://blog.csdn.net/itas109/article/details/122677006\" 2021 开发何不换种姿势 LLVM+clang+Meson+ninja_展桑~~的博客-CSDN博客 https://blog.csdn.net/JasonCrawford/article/details/121892390\" ","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""},{"content":"相关网址 官网：https://github.com/VSCodium/vscodium\n设置VSCodium采用微软官方扩展源 参考：https://zhuanlan.zhihu.com/p/276000982 vscodium默认使用的扩展源是open-vsx.org，部分扩展没有加入此扩展源，需要使用微软官方扩展源才能直接安装和自动更新。\n修改安装根目录/resources/app/product.json文件中的extensionsGallery键对应的值如下：\n1 2 3 4 \u0026#34;extensionsGallery\u0026#34;: { \u0026#34;serviceUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/_apis/public/gallery\u0026#34;, \u0026#34;itemUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/items\u0026#34; } 重启vscodium。扩展里就可以搜索安装微软官方扩展源里的扩展。\n","date":"0001-01-01T00:00:00Z","permalink":"https://www.yprnet.cc/p/","title":""}]