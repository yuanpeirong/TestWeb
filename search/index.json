[{"content":"参考资料1 https://github.com/niXman/mingw-builds https://gcc.gnu.org/install/configure.html https://github.com/niXman/mingw-builds/issues/666 常规MinGw-w64编译步骤(以GCC13.2.0为例) 环境：Windows-64bit or Linux + Wine-64bit\n安装MSYS2：Install MSYS2 from: http://sourceforge.net/projects/msys2/ (MSYS2 wiki: https://www.msys2.org/wiki/MSYS2-installation/)\n把来自niXman的编译脚本放到以下目录 Get the scripts into \u0026lt;msys root\u0026gt;/home/\u0026lt;user\u0026gt;/mingw-builds: cd \u0026amp;\u0026amp; git clone \u0026lt;paste correct url\u0026gt;\ngit clone https://github.com/niXman/mingw-builds.git\n在MSYS2环境中删除以下文件夹或重命名 In the MSYS2 file structure delete or rename the /mingw32 and /mingw64 directory.\n从环境变量中删除指向任何预安装的 MinGW 的路径 Delete the paths pointing to any preinstalled MinGW from the PATH environment variable.\n进入以下目录 Go into the MinGW-builds root directory: cd \u0026amp;\u0026amp; cd mingw-builds\n编译选项Options\n运行Run: （注意：编译运行前需做本地化修改，详见下文）\n1 2 cd mingw-builds ./build --mode=gcc-13.2.0 --buildroot=/c/buildroot --jobs=4 --rev=0 --with-default-msvcrt=ucrt --rt-version=v11 --threads=posix --exceptions=seh --arch=x86_64 --bin-compress --enable-languages=c,c++,fortran 编译得到的编译器为：\nc:\\buildroot\\archives\\x86_64-13.2.0-release-posix-seh-ucrt-rt_v11-rev0.7z\n其中c:\\buildroot为上一步由--buildroot=/c/buildroot指定 本地化需要修改内容(以GCC13.2.0为例) 编译前修改编译参数: 脚本文件：scripts/gcc-13.2.0.sh 将--disable-nls修改为--enable-nls (可选)将仓库中所有文件的--disable-nls修改为--enable-nls 修改gcc源码中gcc\\intl.cc文件进行修改，详见下文：参考资料2。\n这里要重点说明的是，gcc的源码是编译脚本自动下载的，正常见情况下无法修改。\n这里提供两个方法： 方法1：编译完成后去 c:\\buildroot\\src目录找到gcc-13.2.0\\gcc\\intl.cc修改，然后重新编译。 方法2：脚本文件：scripts/gcc-13.2.0.sh中有gcc的源码的下载地址，下载下来修改代码后再传到网上(我用了我自己的云服务器)，并将这个下载地址修改为你的地址。 1 2 3 4 5 6 7 8 # 脚本文件：scripts/gcc-13.2.0.sh PKG_VERSION=13.2.0 PKG_NAME=gcc-${PKG_VERSION} PKG_DIR_NAME=gcc-${PKG_VERSION} PKG_TYPE=.tar.xz PKG_URLS=( \u0026#34;https://ftpmirror.gnu.org/gnu/gcc/gcc-${PKG_VERSION}/gcc-${PKG_VERSION}${PKG_TYPE}\u0026#34; ) 上述网址即https://ftpmirror.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.xz\n我这里改为了http://www.yuanpeirong.com/gcc-13.2.0.tar.xz\n因资金有限，编译后，现在我已经在我的服务器上删除了，你不用找了\n编译完成后解压编译器：x86_64-13.2.0-release-posix-seh-ucrt-rt_v11-rev0.7z\n在mingw64目录下，将share\\locale\\zh_CN\\LC_MESSAGES\\*.*拷贝一份至\nlibexec\\gcc\\x86_64-w64-mingw32\\下，最后形成的路径为\nlibexec\\gcc\\x86_64-w64-mingw32\\share\\locale\\zh_CN\\LC_MESSAGES\\*.* 结果说明 情况1，只改第1条\n需依赖C:\\msys64\\mingw64\\share\\locale\\zh_CN\\LC_MESSAGES\\gcc.mo才能输出中文。\n其中C:\\msys64\\mingw64是编译MinGW64 GCC13.2.0时用的编译器的路径。视编译情况需调整。gcc.exe、g++.exe、cc1.exe、cc1plus.exe都依赖这个路径。\n情况2，只改第1、2条\n只有gcc -v、gcc --version、gcc --help能输出中文。\n情况3，全改第1、2、3条\nWindows 7/8.1控制台正常。windows 10/11控制台正常输出错误提示时中文乱码。\n但在小熊猫C++使用此编译器时，Windows 7/8.1/10/11全部正常。因为其使用管道。\n网友猜测可能原因：\nGCC为了兼容Windows残废的VT序列用力过猛，结果遇到真支持VT序列的Windows就抓瞎了\n用Github Action自动编译 可快速编译各个版本，此处不另外展开\n参考资料2 《MinGW/GCC 编译器修改 gettext 初始化路径使之能在任意位置输出中文消息》\n来源：https://blog.csdn.net/hackpascal/article/details/15222083\n原文摘抄如下：\nGCC 编译器支持 gettext 的本地化，MinGW 也一样，只是可惜他们在内部实现时使用了绝对路径。这个绝对路径的前缀(prefix) 由编译时传递给 configure 的 \u0026ndash;prefix 设定，这样就导致了 MinGW 只有在指定的位置上才能实现编译消息本地化。\n我所做的就是让 GCC 在初始化 gettext 时使用相对路径，这样就能使 MinGW 在任何地方都能使用本地化的字符串了。包含文件搜索路径也同理。\n通过查找 bindtextdomain 函数可以知道 gcc 对 gettext 的初始化在 gcc\\intl.cc 中完成。包含文件搜索路径定义在 incpath.c 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void gcc_init_libintl (void) { #ifdef HAVE_LC_MESSAGES setlocale (LC_CTYPE, \u0026#34;\u0026#34;); setlocale (LC_MESSAGES, \u0026#34;\u0026#34;); #else setlocale (LC_ALL, \u0026#34;\u0026#34;); #endif (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); (void) textdomain (\u0026#34;gcc\u0026#34;); /* Opening quotation mark. */ open_quote = _(\u0026#34;`\u0026#34;); /* Closing quotation mark. */ close_quote = _(\u0026#34;\u0026#39;\u0026#34;); #if defined HAVE_LANGINFO_CODESET locale_encoding = nl_langinfo (CODESET); if (locale_encoding != NULL \u0026amp;\u0026amp; (!strcasecmp (locale_encoding, \u0026#34;utf-8\u0026#34;) || !strcasecmp (locale_encoding, \u0026#34;utf8\u0026#34;))) locale_utf8 = true; #endif if (!strcmp (open_quote, \u0026#34;`\u0026#34;) \u0026amp;\u0026amp; !strcmp (close_quote, \u0026#34;\u0026#39;\u0026#34;)) { /* Untranslated quotes that it may be possible to replace with U+2018 and U+2019; but otherwise use \u0026#34;\u0026#39;\u0026#34; instead of \u0026#34;`\u0026#34; as opening quote. */ open_quote = \u0026#34;\u0026#39;\u0026#34;; #if defined HAVE_LANGINFO_CODESET if (locale_utf8) { open_quote = \u0026#34;\\xe2\\x80\\x98\u0026#34;; close_quote = \u0026#34;\\xe2\\x80\\x99\u0026#34;; } #endif } } 由于我所做的是针对 Windows 下的修改，因此所有改动都要加上 #ifdef WIN32 \u0026hellip; #endif\n首先在开头加上：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #ifdef WIN32 #include \u0026lt;windows.h\u0026gt; BOOL DirectoryExists(LPSTR lpszPath) { WIN32_FIND_DATA wfd; BOOL bResult = FALSE; HANDLE hFind = FindFirstFile(lpszPath, \u0026amp;wfd); if ((hFind != INVALID_HANDLE_VALUE) \u0026amp;\u0026amp; (wfd.dwFileAttributes \u0026amp; FILE_ATTRIBUTE_DIRECTORY)) { bResult = TRUE; } FindClose(hFind); return bResult; } #endif 其中 DirectoryExists 是用来判断路径是否存在的。\n然后修改 (void) bindtextdomain (\u0026ldquo;gcc\u0026rdquo;, LOCALEDIR); 为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #ifndef WIN32 (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); #else DWORD dwSize = MAX_PATH + 20; LPSTR lpszName = (LPSTR) xmalloc(dwSize); DWORD dwRealSize = GetModuleFileNameA(NULL, lpszName, dwSize) + 1; if (dwRealSize \u0026gt; dwSize) { lpszName = (LPSTR) xrealloc(lpszName, dwSize + 20); GetModuleFileNameA(NULL, lpszName, dwRealSize + 20); } /* 去掉文件名 */ int l = strlen(lpszName); while (l \u0026gt;= 0) { if (lpszName[l] == \u0026#39;\\\\\u0026#39;) break; l--; } lpszName[l] = 0; /* 去掉一层文件夹 */ l = strlen(lpszName); while (l \u0026gt; 0) { if (lpszName[l] == \u0026#39;\\\\\u0026#39;) break; l--; } /* 判断是否到根路径 */ if (lpszName[l] != \u0026#39;\\\\\u0026#39;) (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); else { // 连接上 share\\locale lpszName[l + 1] = 0; strcat(lpszName, \u0026#34;share\\\\locale\u0026#34;); if (DirectoryExists(lpszName)) (void) bindtextdomain (\u0026#34;gcc\u0026#34;, lpszName); else (void) bindtextdomain (\u0026#34;gcc\u0026#34;, LOCALEDIR); } free(lpszName); #endif 这样重新编译后，无论 MinGW 位置在哪，它都能显示翻译后的消息了。\n","date":"2024-01-08T23:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-gcc-locale-windows-mingw64/","title":"MinGW-w64 GCC本地化-Windows"},{"content":"编译-GCC13.2.0-x64-2023-12-29 编译器版本\nMinGW-w64版本：x86_64-13.2.0-release-posix-seh-ucrt-rt_v11-rev1.7z\ngcc version 13.2.0 (x86_64-posix-seh-rev1, Built by MinGW-Builds project)\ngcc.exe (x86_64-posix-seh-rev1, Built by MinGW-Builds project) 13.2.0\nD:\\MinGW-w64-ucrt\\bin\\g++.exe\n生成\u0026quot;D:\\Code\\boost_1_84_0\\b2.exe\u0026quot;\n1 2 cd D:\\Code\\boost_1_84_0 bootstrap gcc 编译\n1 b2 -j16 --build-dir=.\\TYbuild --build-type=complete --prefix=.\\gcc1320_x64 link=static,shared threading=single,multi runtime-link=static,shared address-model=64 toolset=gcc variant=debug,release install 备注\n-jN：同时使用N个子线程编译，根据机器需要选取不同的线程数目 \u0026ndash;build-dir：编译生成的中间文件的路径。默认为X:\\boost_X_XX_X\\boost\\bin.v2，等编译完成后删除 \u0026ndash;build-type= 编译类型，可选minimal（最小）、complete（完整），默认minimal。 \u0026ndash;with- 加入此参数，代表只编译的库。 \u0026ndash;without- 加入此参数，代表忽略编译的库。 \u0026ndash;without/\u0026ndash;with：选择不编译/编译哪些库。因为python、mpi等库我都用不着，所以排除之。还有wave、graph、math、regex、test、program_options、serialization、signals这几个库编出的静态lib都非常大，所以不需要的也可以without。这可以根据各人需要进行选择，默认是全部编译。但是需要注意，如果选择编译python的话，是需要python语言支持的，可以到python官方主页下载安装。查看boost包含库的命令是bjam \u0026ndash;show-libraries。 \u0026ndash;layout=versioned link：生成动态链接库/静态链接库。生成动态链接库需使用shared方式，生成静态链接库需使用static方式。一般boost库可能都是以static方式编译，因为最终发布程序带着boost的dll感觉会比较累赘。 threading：单/多线程编译。一般都写多线程程序，当然要指定multi方式了；如果需要编写单线程程序，那么还需要编译单线程库，可以使用single方式。 stage/install：stage表示只生成库（dll和lib），install还会生成包含头文件的include目录。推荐使用stage，因为install生成的这个include目录实际就是boost安装包解压缩后的boost目录（X:\\boost_X_XX_X\\boost，只比include目录多几个非hpp文件，都很小），所以可以直接使用，而且不同的IDE都可以使用同一套头文件，这样既节省编译时间，也节省硬盘空间。 runtime-link：动态/静态链接C/C++运行时库。同样有shared和static两种方式，这样runtime-link和link一共可以产生4种组合方式，各人可以根据自己的需要选择编译。 toolset：指定编译器，可选的如borland、gcc、msvc（VC6）、msvc-10.0（VS2010）、msvc-12.0（VS2013）、msvc-14.0（VS2015）等。 stagedir/\u0026ndash;prefix：stage时使用stagedir，install时使用prefix，表示编译生成文件的路径。推荐给不同的IDE指定不同的目录，如VS2015对应的是 X:\\boost_X_XX_X\\vc10,如果使用了install参数，那么还将生成头文件目录，vc10对应的就是X:\\boost_X_XX_X\\boost\\bin\\vc10\\include\\boost_X_XX_X\\boost variant：编译debug/release版本。一般都是程序的debug版本对应库的debug版本，所以两个都编译。那么如果需要生成dll，可以使用link=shared方式生成。 编译-GCC13.2.0-x64-2023-12-29 编译器版本\nMinGW-w64版本：x86_64-13.2.0-release-win32-seh-ucrt-rt_v11-rev1.7z 生成\u0026quot;D:\\Code\\boost_1_83_0\\b2.exe\u0026quot;\n1 2 cd D:\\Code\\boost_1_83_0 bootstrap gcc 编译\n1 b2 -j16 --build-dir=.\\tmp --build-type=complete threading=multi link=shared address-model=64 toolset=gcc stage 备注\n“stage”表示生成的Boost库文件会存储于“D:\\Code\\boost_1_83_0\\stage\\lib”文件夹。 库命名规则 .a 静态链接库link=static\n.dll、.dll.a 动态链接库link=shared\n在大多数unix平台上：.so是共享库。.a是静态库 在 Windows上：.dll表示共享库，.lib是静态或导入库。\ns 静态链接C/C++运行时库runtime-link=static\n无s 动态链接C/C++运行时库runtime-link=shared\n无d variant=release版本\nd variant=debug版本\nmt 多线程threading=multi\n无mt 单线程threading=single\ng：使用标准库和运行时支撑库的调试版本\ny：使用 Python的特殊调试构建\np：使用 STLPort标准库而不是编译器提供的默认库\nn：使用 STLPort已被弃用的\u0026quot;native iostreams\u0026quot;\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-boost-compile/","title":"boost库编译"},{"content":"参考资料 Kawaii-gcc本地 Kawaii-gcc网站 ArchLinux设置简体中文 Linux环境 安装中文 (如果没有安装)\n1 sudo apt-get install language-pack-zh-hans language-pack-zh-hans-base 安装 gcc , gettext 和 g++.\n1 sudo apt-get install gcc gettext g++ 安装 gcc locales\n通过以下命令检查你的gcc版本号\n1 gcc -v 我这里是12.3.0.所以我的主版本号是12，安装gcc-12-locales\n1 sudo apt-get install gcc-12-locales 找到你的语言文件的路径。默认会在 /usr/share/locale/zh_CN/LC_MESSAGES/gcc.mo. 不过你也有可能找不到该文件或者找到名为gcc-12.mo的文件。\n如果你在上个步骤找到了相关文件，请直接使用原本的名字。 如果没有，首先使用 gcc-\u0026lt;主版本号\u0026gt;.mo 。如果发现不起作用，将其重命名为 gcc.mo. 修改环境变量以将终端语言改为中文：\n1 2 3 4 5 6 7 8 vim ~/.bashrc # Add the following lines export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LANGUAGE=\u0026#34;zh_CN.UTF-8\u0026#34; # Save it in Vim source ~/.bashrc 实测ArchLinux 已经是中文版 已安装gcc gettext g++ gcc版本为13 没有gcc-13-locales、但有/usr/share/locale/zh_CN/LC_MESSAGES/gcc.mo 只要按上述将终端语言改为中文即可 将gcc.mo替换为kawaii-gcc中的prebuilt/gcc-zh.mo(需重命名为gcc.mo)可成功 将gcc.mo替换为mingw64\\share\\locale\\zh_CN\\LC_MESSAGES\\gcc.mo可成功 实测Ubuntu 22.04 已经是中文版 已安装gcc gettext g++ gcc-11-locales gcc版本为11 将/usr/share/locale-langpack/zh_CN/LC_MESSAGES/gcc.mo复制到/usr/share/locale/zh_CN/LC_MESSAGES/，并改名为gcc-11.mo 按上述将终端语言改为中文即可 备注： 无论是ArchLinux和Ubuntu，我确保设置了\n/etc/locale.gen\n1 zh_CN.UTF-8 UTF-8 /etc/locale.conf (经验证在Ubuntu 22.04上不需要也可以)\n1 LANG=zh_CN.UTF-8 这两个文件我放在\u0026quot;\\192.168.96.2\\ypr-pc\\软件\\Linux\\ArchLinux\\locale配置文件.rar\u0026quot;\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-gcc-locale-linux/","title":"GCC本地化-Linux"},{"content":"本文还未整理完 参考资料 GCC 环境变量 GCC相关的环境变量 LIBRARY_PATH和LD_LIBRARY_PATH环境变量的区别 有大量的环境变量可供设置以影响 GCC 编译程序的方式。利用这些变量的控制也可使用合适的命令行选项。\n一些环境变量设置在目录名列表中。这些名字和 PATH 环境变量使用的格式相同。特殊字符 PATH_SEPARATOR （安装编译程序的时候定义）用在目录名之间。在 UNIX 系统中，分隔符是冒号，而 Windows 系统中为分号。\nC_INCLUDE_PATH 编译 C 程序时使用该环境变量。该环境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定 -isystem 选项一样。会首先查找 -isystem 指定的所有目录。\n也见 CPATH 、 CPLUS_INCLUDE_PATH 和 OBJC_INCLUDE_PATH 。\nCOMPILER_PATH 该环境变量指定一个或多个目录名列表，如果没有指定 GCC_EXEC_PREFIX 定位子程序，编译程序会在此查找它的子程序。\n也见 LIBRARY_PATH 、 GCC_EXEC_PREFIX 和 -B 命令行选项。\nCPATH 编译 C 、 C++ 和 Objective-C 程序时使用该环境变量。该环境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定 -l 选项一样。会首先查找 -l 指定的所有目录。\n也见 C_INCLUDE_PATH 、 CPLUS_INCLUDE_PATH 和 OBJC_INCLUDE_PATH 。\nCPLUS_INCLUDE_PATH 编译 C++ 程序时使用该环境变量。该环境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定 -isystem 选项一样。会首先查找 -isystem 指定的所有目录。\n也见 CPATH 、 C_INCLUDE_PATH 和 OBJC_INCLUDE_PATH 。\nDEPENDENCIES_OUTPUT 为文件名设置该环境变量会让预处理程序将基于依赖关系的 makefile 规则写入文件。不会包括系统头文件名字。\n如果环境变量设置为单名，被看作是文件名字，而依赖关系规则的名字来自源文件名字。如果定义中有两个名字，则第二个名字是用作依赖关系规则的目标名。\n设置该环境变量的结果和使用命令行选项 -MM 、 -MF 和 -MT 的组合是一样的。也见 SUNPRO_DEPENDENCIES 。\nGCC_EXEC_PREFIX 如 果定义了该环境变量，它会作为编译程序执行的所有子程序名字的前缀。例如，如果将变量设置为 testver 而不是查找 as ，汇编器首先会在名字 testveras 下查找。如果在此没有找到，编译程序会继续根据它的普通名进行查找。可在前缀名中使用斜线指出路径名。\nGCC_EXEC_PREFIX 的默认设置为 prefix /lib/gcc-lib/ ，这里的 prefix 是安装编译程序时 configure 脚本指定的名字。该前缀也用于定位标准连接程序文件，包含进来作为可执行程序的一部分。\n如果使用 -B 命令行选项，会重写该设置。也见 COMPILER_PATH 。\nLANG 该环境变量用于指出编译程序使用的字符集，可创建宽字符文字、串文字和注释。\n定义 LANG 为 C-JIS ，指出预处理程序将多字节字符按照 JIS （日语工业标准）字符进行解释。 C-SJIS 可用来指出 Shift -JIS 字符而 C-EUCJP 指出日文 EUC 。\n如果没有定义 LANG ，或定义为不可识别，函数 mblen() 被用来确定字符宽度，而 mbtowc() 用来将多字节序列转换为宽字符。\nLC_ALL 如果设置，该环境变量的值重写 LC_MESSAGES 和 LC_CTYPE 的所有设置。\nLC_CTYPE 该 环境变量指出引用串中定义的多字节字符的字符分类。主要用于确定字符串的字符边界，字符编码需要用引号或转义符，可被错误地解释为字符串的结尾或特殊字符 串。对 Australian English ，可将它设置为 en_AU ； 对 Mexican Spanish ，可将它设置为 es_MX 。如果没有设置该变量，默认为 LANG 变量的值，或如果没有设置 LANG ，那就使用 C 英语行为。也见 LC_ALL 。\nLC_MESSAGES 该 环境变量指出编译程序使用何种语言发出诊断消息。对 Australian English ，可设置为 en_AU ； 对 Mexican Spanish ，可设置为 es_MX 。如果变量没有设置，使用 LANG 变量的默认值，或如果没有设置 LANG ，那就使用 C 英语行为。也见 LC_ALL 。\nLD_LIBRARY_PATH 该环境变量不会影响编译程序，但程序运行的时候会有影响。变量指定一个目录列表，程序会查找该列表定位共享库。只有当未在编译程序的目录中找到共享库的时候，执行程序必须设置该变量。\nLD_RUN_PATH 该环境变量不会影响编译程序，但程序运行的时候会有影响。该变量在运行时指出文件的名字，运行的程序可由此得到它的符号名字和地址。地址不会重新载入，因而可能符号引用其他文件中的绝对地址。这和 ld 工具使用 -R 选项完全一样。\nLIBRARY_PATH 该环境变量可设置为一个或多个目录名字列表，连接程序会搜寻该目录，以查找特殊连接程序文件，和由 -l （字母 l ）命令行选项指定名字的库。\n由 -L 命令行选项指定的目录在环境变量的前面，首先被查找。也见 COMPILER_PATH 。\nOBJC_INCLUDE_PATH 在编译 Objective-C 程序的时候使用该环境变量。一个或多个目录名的列表由环境变量指定，用来查找头文件，就好像在命令行中指定 -isystem 选项一样。所有由 -isystem 选项指定的目录会首先被查找。\n也见 CPATH 、 CPLUS_INCLUDE_PATH 和 C_INCLUDE_PATH 。\nSUNPRO_OUTPUT 为文件名设置该环境变量会令预处理程序将基于依赖关系的 makefile 规则写入文件。会包含系统头文件名。\n如果环境变量被设置为单个名字，它将会被当作文件名，依赖关系规则中的名字将由源文件的名字中获得。如果定义中有两个名字，第二个名字就是依赖关系规则中的目标名。\n设置该环境变量的结果与在命令行中使用参数 -M 、 -MF 和 -MT 的效果一样。参见 DEPENDENCIES_OUTPUT 。\nTMPDIR 这个变量包含了供编译程序存放临时工作文件的目录的路径名。这些文件通常在编译过程结束时被删除。这种文件的一个例子就是由预处理程序输出并输入给编译程序的文件。\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-gcc-env-var/","title":"GCC环境变量"},{"content":" 转自：https://github.com/Bill-Haku/kawaii-gcc/blob/main/README-zh.md 让你的GCC编译器变得可爱！\n本项目通过修改GCC的输出信息的本地化文件的方式让GCC变得可爱。\n欢迎贡献更多有趣的内容。\n依赖 GNU GCC GNU Gettext 如何使用？ Linux (以Ubuntu为例) 中文版使用教程视频-Bilibili\n日语版使用教程视频-Bilibili\n日语版使用教程视频-YouTube\n安装中文 (如果没有安装)\n1 sudo apt-get install language-pack-zh-hans language-pack-zh-hans-base 安装 gcc , gettext 和 g++.\n1 sudo apt-get install gcc gettext g++ 安装 gcc locales\n通过以下命令检查你的gcc版本号\n1 gcc -v 我这里是12.3.0.所以我的主版本号是12，安装gcc-12-locales\n1 sudo apt-get install gcc-12-locales 找到你的语言文件的路径。默认会在 /usr/share/locale/zh_CN/LC_MESSAGES/gcc.mo. 不过你也有可能找不到该文件或者找到名为gcc-12.mo的文件。如果已有相关文件，备份之。 (eg. sudo mv gcc-12.mo gcc-12.mo.bak) 如果没有相关文件，无需担心，什么都不需要做。\n通过以下命令下载仓库中的mo 文件然后将其复制到刚才的路径去。\n1 sudo wget https://github.com/Bill-Haku/kawaii-gcc/raw/main/prebuilt/gcc-zh.mo -O /usr/share/locale/zh_CN/LC_MESSAGES/gcc-12.mo 您也可以自行重新编译该二进制文件：\n1 2 3 make merge-zh msgfmt gcc-zh.po -o gcc.mo sudo cp gcc.mo /usr/share/locale/zh_CN/LC_MESSAGES/gcc-12.mo 或\n1 make 关于文件名：\n如果你在上个步骤找到了相关文件，请直接使用原本的名字。 如果没有，首先使用 gcc-\u0026lt;主版本号\u0026gt;.mo 。如果发现不起作用，将其重命名为 gcc.mo. 修改环境变量以将终端语言改为中文：\n1 2 3 4 5 6 7 8 vim ~/.bashrc # Add the following lines export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LANGUAGE=\u0026#34;zh_CN.UTF-8\u0026#34; # Save it in Vim source ~/.bashrc 现在你的GCC已经变得可爱了。\n你可以使用附带的 test.cc 来试试效果。\n1 2 gcc test.cc -Wall # -Wall 表示让GCC输出所有警告信息 Windows 安装 Cygwin。\n步骤：\n下载并运行 setup-x86_64.exe 在 选择下载源 (Choose A Download Source) 步骤时选择 从互联网安装 (Install from Internet)\n在 选择软件包 (Select Packages) 步骤时, 将查看 (View) 设为 类别 (Category) 并依次搜索 (Search) 并选择 ALL/Devel 下的 gcc-core，gcc-g++ 和 gettext 的版本 假设你的 Cygwin 安装目录 (注意不是软件包下载目录) 为 \u0026lt;DIR\u0026gt; (默认应该是 C:\\cygwin), 将目录 \u0026lt;DIR\u0026gt;\\bin 目录添加到环境变量 Path 中 (如果 Path 中已经有 mingw 了, 请删除或者移到\u0026lt;DIR\u0026gt;\\bin的下方), 并额外增加一条环境变量 LANG, 设置为 zh_CN.UTF-8\n将本仓库的 prebuilt 目录下的 gcc-zh.mo 放到 \u0026lt;DIR\u0026gt;\\usr\\share\\locale\\zh_CN\\LC_MESSAGES 目录下, 并将其重命名为 gcc.mo (建议先将原来的gcc.mo备份)\nmacOS 暂未实现。欢迎贡献。\n如何修改/贡献 前往./src目录，使用文本编辑器打开并编辑zh-kawaii.po。可以修改已有的内容，也可以根据原始简体中文本地化文件增加新内容。编辑完成后运行make指令合并文件，并将其编译成mo文件后拷贝到指定的地方。\n关于src目录下的文件 zh_CN.po: GNU提供的原始简体中文版本地化文件。 zh_kawaii.po: 本项目已修改的本地化内容。 如果您愿意参与贡献本项目 请在PR时将您修改完成的编译好的mo文件放在../prebuilt目录下，以更新预编译好的本地化二进制文件。\nStar History 特别鸣谢 本项目的灵感来自gcc-hentai项目。为了将其推广到日语区，我创建了本仓库、制作了日语版并修改完善了使用说明的诸多细节，最后制作了完全日语的宣传视频发布在YouTube，不料却在Bilibili获得了关注。十分感谢原作者的分享和开源精神。\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-kawaii-gcc/","title":"Kawaii-gcc 让GCC变得可爱"},{"content":"教程 菜鸟教程：https://www.runoob.com/markdown/md-tutorial.html\n软件 Visual Studio Code Visual Studio Code 是众所周知的神器，是微软推出一款轻量级的文本编辑工具，类似于 Sublime，它已经默认集成 Markdown 文档编辑插件，原生就支持高亮 Markdown 的语法，但想要实时预览还需要选择 Markdown: Open Preview to the Side 命令实现，相关教程请点击此处\nhttps://www.cnblogs.com/shawWey/p/8931697.html\nTypora 官网：https://typora.io/\n中文官网：https://typoraio.cn/\n果核剥壳：https://www.ghxi.com/typora.html\nMarkText 官网：https://marktext.app/\nGitHub：https://github.com/marktext/marktext\nGitHub中文包：https://github.com/chinayangxiaowei/marktext-chinese-language-pack\n中文说明书：https://zhuanlan.zhihu.com/p/438852089\n相关介绍：\nhttps://zhuanlan.zhihu.com/p/348367255 notable GitHub：https://github.com/notable/notable\nHBuilderX 官网：https://dcloud.io/hbuilderx.html\nMilkdown 官网：https://milkdown.dev/\nGitHub：https://github.com/Milkdown/milkdown\n果核剥壳：https://www.ghxi.com/wx20211206.html\nVS Code 插件：https://marketplace.visualstudio.com/items?itemName=mirone.milkdown\n在线体验：https://milkdown.dev/#/online-demo\n相关介绍：\nhttps://juejin.cn/post/7131641368283185182 StackEdit(网页版) 官网：https://stackedit.cn/app\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/soft/notes-markdown/","title":"Markdown"},{"content":"官网 https://www.syntevo.com/smartgit/ 注册非商业许可证 https://www.syntevo.com/cn/smartgit/register-non-commercial/ ","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/soft/git-smartgit/","title":"SmartGit"},{"content":"相关网址 官网：https://code.visualstudio.com/ 文档：https://code.visualstudio.com/docs 变量参考 来源：https://code.visualstudio.com/docs/editor/variables-reference 预定义变量 支持以下预定义变量：\n${userHome} - 用户主文件夹的路径 ${workspaceFolder} - 在 VS Code 中打开的文件夹的路径 ${workspaceFolderBasename} - 在 VS Code 中打开的文件夹的名称，不带任何斜杠 （/） ${file} - 当前打开的文件 ${fileWorkspaceFolder} - 当前打开的文件的工作区文件夹 ${relativeFile} - 当前打开的文件相对于workspaceFolder ${relativeFileDirname} - 当前打开的文件的目录名相对于workspaceFolder ${fileBasename} - 当前打开的文件的基名 ${fileBasenameNoExtension} - 当前打开的文件的 basename，没有文件扩展名 ${fileExtname} - 当前打开的文件的扩展名 ${fileDirname} - 当前打开的文件的文件夹路径 ${fileDirnameBasename} - 当前打开的文件的文件夹名称 ${cwd} - VS Code 启动时任务运行程序的当前工作目录 ${lineNumber} - 活动文件中当前选定的行号 ${selectedText} - 活动文件中当前选定的文本 ${execPath} - 正在运行的 VS Code 可执行文件的路径 ${defaultBuildTask} - 默认构建任务的名称 ${pathSeparator} - 操作系统用于分隔文件路径中组件的字符 预定义变量示例 假设您有以下要求： 位于编辑器中打开的文件;/home/your-username/your-project/folder/file.ext 作为根工作区打开的目录。/home/your-username/your-project 因此，每个变量将具有以下值：\n${userHome} - /home/your-username ${workspaceFolder} - /home/your-username/your-project ${workspaceFolderBasename} - your-project ${文件} - /home/your-username/your-project/folder/file.ext ${fileWorkspaceFolder} - /home/your-username/your-project ${relativeFile} - folder/file.ext ${relativeFileDirname} - folder ${fileBasename} - file.ext ${fileBasenameNoExtension} - file ${fileDirname} - /home/your-username/your-project/folder ${fileExtname} - .ext ${lineNumber} - 游标的行号 ${selectedText} - 在代码编辑器中选择的文本 ${execPath} - Code.exe 的位置 ${pathSeparator} - 在 macOS 或 linux 上，在 Windows 上/\n提示：在字符串值中使用 IntelliSense，以获取预定义变量的完整列表。tasks.jsonlaunch.json 参考资料 C++相关 在vscode配置C++环境(clang编译器) 傻瓜式配置向导 - nikiss - 博客园 https://www.cnblogs.com/nikiss/p/14208341.html vscode+clang+llvm 搭建 C++ 编译环境（windows） - 知乎 https://zhuanlan.zhihu.com/p/613922486\" 配置 C++: LLVM (Clang + Clangd + LLDB) v2.1.0 文档 https://windowsmacos-vscode-c-llvm-clang-clangd-lldb.readthedocs.io/index.html 使用 WSL 在 VScode上用 LLVM + Clangd + LLDB高效编程 C++_wsl 安装codelldb_海涛的学习笔记的博客-CSDN博客 https://blog.csdn.net/qq_25534975/article/details/121931415\" vscode C++ debug: lldb: unrecognized option `\u0026ndash;interpreter=mi_lldb \u0026ndash;interpreter_旧人赋荒年的博客-CSDN博客 https://blog.csdn.net/yangziluomu/article/details/100037876\" vscode使用lldb调试C++程序_vscode lldb-CSDN博客 https://blog.csdn.net/itas109/article/details/122677006\" 2021 开发何不换种姿势 LLVM+clang+Meson+ninja_展桑~~的博客-CSDN博客 https://blog.csdn.net/JasonCrawford/article/details/121892390\" ","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/soft/text-visualstudiocode/","title":"VisualStudioCode"},{"content":"相关网址 官网：https://github.com/VSCodium/vscodium\n设置VSCodium采用微软官方扩展源 参考：https://zhuanlan.zhihu.com/p/276000982 vscodium默认使用的扩展源是open-vsx.org，部分扩展没有加入此扩展源，需要使用微软官方扩展源才能直接安装和自动更新。\n修改安装根目录/resources/app/product.json文件中的extensionsGallery键对应的值如下：\n1 2 3 4 \u0026#34;extensionsGallery\u0026#34;: { \u0026#34;serviceUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/_apis/public/gallery\u0026#34;, \u0026#34;itemUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/items\u0026#34; } 重启vscodium。扩展里就可以搜索安装微软官方扩展源里的扩展。\n","date":"2024-01-07T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/soft/text-vscodium/","title":"VSCodium"},{"content":"官网 https://www.msys2.org/ 换源 1 sed -i \u0026#34;s#https\\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g\u0026#34; /etc/pacman.d/mirrorlist* 清华源帮助：https://mirror.tuna.tsinghua.edu.cn/help/msys2/ MSYS2中MINGW_PACKAGE_PREFIX对应关系 参考：https://www.msys2.org/docs/package-naming/ 参考：https://www.msys2.org/docs/environments/ Name MINGW_PACKAGE_PREFIX MSYS None MINGW64 mingw-w64-x86_64- UCRT64 mingw-w64-ucrt-x86_64- CLANG64 mingw-w64-clang-x86_64- MINGW32 mingw-w64-i686- CLANG32 mingw-w64-clang-i686- CLANGARM64 mingw-w64-clang-aarch64- 安装记录 安装工具链 pacman -S mingw-w64-x86_64-toolchain pacman -S mingw-w64-ucrt-x86_64-toolchain pacman -S mingw-w64-clang-x86_64-toolchain pacman -S mingw-w64-i686-toolchain pacman -S mingw-w64-clang-i686-toolchain pacman -S mingw-w64-clang-aarch64-toolchain pacman -S $MINGW_PACKAGE_PREFIX-toolchain 安装Qt5库 pacman -S mingw-w64-x86_64-qt5-static pacman -S mingw-w64-ucrt-x86_64-qt5-static pacman -S mingw-w64-clang-x86_64-qt5-static pacman -S mingw-w64-i686-qt5-static pacman -S mingw-w64-clang-i686-qt5-static pacman -S mingw-w64-clang-aarch64-qt5-stat pacman -S $MINGW_PACKAGE_PREFIX-qt5-static 安装Qt6库 pacman -S mingw-w64-ucrt-x86_64-qt6-static 仅安装编译工具 pacman -S mingw-w64-ucrt-x86_64-gcc pacman -S mingw-w64-x86_64-gcc pacman -S mingw-w64-i686-gcc pacman -S mingw-w64-clang-x86_64-gcc pacman -S mingw-w64-clang-i686-gcc 安装make pacman -S mingw-w64-ucrt-x86_64-make pacman -S mingw-w64-clang-x86_64-make 安装GDB pacman -S mingw-w64-ucrt-x86_64-gdb pacman -S mingw-w64-clang-x86_64-lldb 仅MSYS2环境下的工具安装 pacman -S binutils //二进制工具集 pacman -S gcc //GNU编译器集合-C和C++前端\npacman -S gcc-libs //GCC提供的运行时库 pacman -S gdb //GNU调试器 pacman -S gettext //GNU国际化库 pacman -S gettext-devel //GNU国际化开发实用程序 pacman -S make //make工具\n安装其他 pacman -S base //Minimal package set to define a basic MSYS2 installation pacman -S base-devel //Minimal package set for building packages with makepkg pacman -S vim pacman -S yasm pacman -S nasm 备注 MSYS2中有两种工具链：\n一种是原生GCC，其编译的是UNIX代码，运行依赖msys2xxx.dll； 一种是mingw工具链，用于编译windows代码（能调用windows API，不能调用unix系统调用）的， 生成exe，运行时只依赖windows系统的dll。 更新和维护MSYS2 参考：https://www.msys2.org/docs/updating/ 通过安装程序或其他方式安装 MSYS2 后，您需要继续使用内置工具对其进行更新。MSYS2 是一个滚动发布发行版，仅支持完整的系统升级，这意味着各种软件包经常进行次要和主要更新，并且您只能一次更新所有软件包。 若要更新所有包，请运行以下命令：\n1 2 3 4 5 6 7 8 9 10 11 12 $ pacman -Suy :: Synchronizing package databases... mingw32 is up to date mingw64 is up to date ucrt64 is up to date clang32 is up to date clang64 is up to date msys is up to date :: Starting core system upgrade... there is nothing to do :: Starting full system upgrade... there is nothing to do 在某些情况下，某些核心软件包会被更新，pacman 会提示你关闭所有终端：\n1 2 :: To complete this update all MSYS2 processes including this terminal will be closed. Confirm to proceed [Y/n] 确认后，您需要启动一个新终端并再次运行更新，以更新剩余的非核心包。pacman -Suy\n其他命令参考 1. 安装软件 pacman -S 软件名: 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -S \u0026ndash;needed 软件名1 软件名2: 安装软件，但不重新安装已经是最新的软件。 pacman -Sy 软件名：安装软件前，先从远程仓库下载软件包数据库(数据库即所有软件列表)。 pacman -Sv 软件名：在显示一些操作信息后执行安装。 pacman -Sw 软件名: 只下载软件包，不安装。 pacman -U 软件名.pkg.tar.gz：安装本地软件包。 pacman -U http://www.example.com/repo/example.pkg.tar.xz : 安装一个远程包（不在 pacman 配置的源里面）。 2. 更新系统 pacman -Sy: 从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。 pacman -Su: 升级所有已安装的软件包。 3. 卸载软件 pacman -R 软件名: 该命令将只删除包，保留其全部已经安装的依赖关系 pacman -Rv 软件名: 删除软件，并显示详细的信息 pacman -Rs 软件名: 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Rsc 软件名: 删除软件，并删除所有依赖这个软件的程序，慎用 pacman -Ru 软件名: 删除软件,同时删除不再被任何软件所需要的依赖 4. 搜索软件 pacman -Ss 关键字: 在仓库中搜索含关键字的软件包（本地已安装的会标记） pacman -Sl :显示软件仓库中所有软件的列表。可以省略，通常这样用:pacman -Sl | 关键字 pacman -Qs 关键字: 搜索已安装的软件包 pacman -Qu: 列出所有可升级的软件包 pacman -Qt: 列出不被任何软件要求的软件包 查看软件信息\npacman -Q 软件名: 查看软件包是否已安装，已安装则显示软件包名称和版本 pacman -Qi 软件名: 查看某个软件包信息，显示较为详细的信息，包括描述、构架、依赖、大小等等 pacman -Ql 软件名: 列出软件包内所有文件，包括软件安装的每个文件、文件夹的名称和路径 5. 软件包组 pacman -Sg: 列出软件仓库上所有的软件包组 pacman -Qg: 列出本地已经安装的软件包组和子包 pacman -Sg 软件包组: 查看某软件包组所包含的所有软件包 pacman -Qg 软件包组: 和pacman -Sg 软件包组完全一样\n6. 清除缓存 pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。\npacman -Scc：清理所有的缓存文件。\npacman 安装包缓存位置及清理\n如果进行系统更新时,磁盘不足,清理软件安装包缓存是一种可行的方案.\npacman 会将自己下载的软件压缩包保存在 /var/cache/pacman/pkg/目录下,\n默认情况下并不会删除安装包,即便软件已经卸载.\n下面提供几个清理程度不同的命令.\npaccache -r # 清理缓存,仅包含最近的三个版本\npaccache -rk1 # 清理缓存,仅包含最近的1个版本\npacman -Sc # 清理未安装软件包\npacman -Scc # 清理缓存中所有内容\n","date":"2023-11-24T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/msys2/","title":"MSYS2"},{"content":"参考资料 GCC本地化-Linux 注意 本文是指MSYS2主环境中的gcc，不是指mingw64、mingw64、mingw32子环境 缺点是：即便静态链接，生成的exe程序还是需要msys-2.0.dll MSYS2主环境 安装 1 2 3 4 pacman -S gcc //GNU编译器集合-C和C++前端 pacman -S gcc-libs //GCC提供的运行时库 我不确定是否必需 pacman -S gettext //GNU国际化库 pacman -S gettext-devel //GNU国际化开发实用程序 我不确定是否必需 \u0026ldquo;D:\\msys64\\home\\YuanPeirong.bashrc\u0026quot;加入 1 2 export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LANGUAGE=\u0026#34;zh_CN.UTF-8\u0026#34; gcc.mo\ngcc版本为13\n确保有\u0026quot;D:\\msys64\\usr\\share\\locale\\zh_CN\\LC_MESSAGES\\gcc.mo\u0026rdquo;\n外部使用\n方法1：设置系统环境变量\n变量名：LANG 变量值：zh_CN.UTF-8\n变量名：LANGUAGE 变量值：zh_CN.UTF-8\n方法2：在bat文件中写入以下变量，再启动其他外部工具\n1 2 set LANG=zh_CN.UTF-8 set LANGUAGE=zh_CN.UTF-8 方法3：写个exe文件设置变量，再调用真正要使用的外部工具（未测试）\n方法4：写个run.ps1脚本（未测试）\n方法5：设置临时变量，用分号执行多条命令，如：\nexport LANG=\u0026quot;zh_CN.UTF-8\u0026quot;;export LANGUAGE=\u0026quot;zh_CN.UTF-8\u0026quot;;gcc -v\nexport LANG=\u0026quot;zh_CN.utf8\u0026quot;;export LANGUAGE=\u0026quot;zh_CN.utf8\u0026quot;;gcc -v\n以上两条命令都有效。\nzh_CN.UTF-8和zh_CN.utf8是等效的\n但gcc源码的文档中是用zh_CN.utf8描述的\n","date":"2023-11-24T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/msys2-gcc-locale/","title":"MSYS2中的GCC本地化"},{"content":"参考资料 https://doc.qt.io/qt-5/windows-building.html https://doc-snapshots.qt.io/qt5-5.15/windows-building.html https://doc.qt.io/qt-5/supported-platforms.html https://doc.qt.io/qt-5/windows.html https://doc.qt.io/qt-5/windows-requirements.html https://doc.qt.io/qt-5/configure-options.html https://wiki.qt.io/Building_Qt_5_from_Git https://wiki.qt.io/MinGW-64-bit https://blog.csdn.net/zxjohnson/article/details/106621457 (Qt 5.15.0编译指南) https://blog.csdn.net/MrTsai_cpp/article/details/115175669 (Qt 5.15的源码编译(Windows)) https://www.cnblogs.com/arxive/p/14412614.html (QT 5.15 及以后QT版本源码编译（静态库、动态库）) https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) https://blog.csdn.net/Comewood/article/details/125697120 （Windows10 Qt 遇到EGL/egl.h: No such file or directory 解决方法） 下载源码包 https://download.qt.io/archive/qt/5.15/5.15.11/single/qt-everywhere-opensource-src-5.15.11.zip 安装build工具并配置相关环境变量 D:\\Qt\\Tools\\mingw810_64\\bin These tools are not needed to run Qt 5 applications, but they are required for building Qt 5 from source. Perl - Install a recent version of perl (for instance (https://strawberryperl.com/) and add the installation location to your PATH. Python - Install Python from the here and add the installation location to your PATH. 验证build工具是否正确安装 打开cmd(不要关闭) 输入 1 2 3 4 5 set PATH=D:\\Qt\\Tools\\mingw810_64\\bin;%PATH% gcc -v g++ -v perl -V python -V 设定文件夹 F:\\Qt\\5.15.11\\src 源码目录qt-everywhere-opensource-src-5.15.11.zip解压，并改名为src，放置于F:\\Qt\\5.5.11\\src F:\\Qt\\5.15.11\\build-mingw810_64 build目录 F:\\Qt\\5.15.11-static\\mingw810_64 最后安装目录 编译 建立F:\\Qt\\qt5mingw810_64.cmd文件，需设置好Qt源代码路径、mingw810_64路径(D:\\Qt\\Tools\\mingw810_64\\bin)\n建立cmd链接cmd-qt5mingw810_64，并运行\n比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-mingw810_64 依上述定位到F:\\Qt\\5.15.11\\build-mingw810_64 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\mingw810_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource -opengl desktop -platform win32-g++ mingw32-make -j16 #开启十六线程编译，根据自己电脑实际核心数调整 mingw32-make install 编译(此段内容为历史记录，作废) 在cmd中(上述不要关闭，否则要重新set PATH=D:\\Qt\\Tools\\mingw810_64\\bin;%PATH%)\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt5mingw810_64.cmd文件，需设置好Qt源代码路径、mingw810_64路径 建立cmd链接cmd-qt5mingw810_64，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-mingw810_64 依上述定位到F:\\Qt\\5.15.11\\build-mingw810_64 依次执行命令\n1 2 3 4 #当使用上述qt5vars.cmd文件时，可省略此三行命令，因为已经在qt5vars.cmd文件中执行 SET _ROOT=F:\\Qt\\5.15.11\\src SET PATH=%_ROOT%\\qtbase\\bin;%_ROOT%\\gnuwin32\\bin;%PATH% SET _ROOT= 1 2 3 4 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\mingw810_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource -opengl desktop -platform win32-g++ mingw32-make #2023-11-23实测很慢，可改为 #mingw32-make -j16 #开启十六线程编译，根据自己电脑实际核心数调整 mingw32-make install 说明1 -static就是静态编译的意思，\n-debug-and-release，则表示将调试版、发行版都进行编译。\n-prefix 指定安装将会部署的位置，根据自己情况修改\n-nomake examples 不需要编译示例\n-nomake tests 不需要编译测试工程\n-skip qtwebengine 暂时先不编译webengine模块，因为太大了\n-opensource 开源版本\n-confirm-license 是为了自动确认开源证书，免得到时暂停手动确认\n-qt-zlib -ssl -icu 指示检测这些库，并在需要时使用\n-opengl desktop 明确指示使用你windows上安装的opengl驱动来编译程序，但这样编译出的程序在别的电脑上运行时需要目标电脑上安装的opengl驱动能兼容你的程序\n-platform win32-g++ 指明编译平台是windows，并使用mingw编译器\nFor Windows machines, either MinGW or Visual Studio toolchains can be used to compile Qt. 1 2 configure.bat -platform win32-g++ configure.bat -platform win32-msvc -opengl desktop 切换到desktop版本的opengl，解决错误提示error：EGL/egl.h: No such file or directory\n说明2 等待配置完成后(其间要输入y同意协议)，再运行命令mingw32-make mingw32-make -j16开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令mingw32-make install即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹，释放110多G的空间，它已经没用了。 2023-11-23编译(已删除) 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw810_64\\bin、需数小时更多、7.65GB\nbuild文件约16.9GB，已删除\n未编译doc\n2023-11-24编译 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw810_64\\bin、约44分钟、7.65GB 采用了qt5mingw810_64.cmd、采用了mingw32-make -j16 build文件约16.9GB，已删除 未编译doc 存档：7z(9-极限压缩） 2023-11-28编译(仅-release YPR-Desktop) 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw810_64\\bin、约15分钟、932MB 采用了qt5mingw810_64.cmd、采用了mingw32-make -j16 build文件约2.52GB，已删除 未编译doc 存档：7z(9-极限压缩） 2023-11-28编译(仅-release YPR-Server) 环境：YPR-Server、Windows 10 pro 22H2、D:\\Qt\\Tools\\mingw810_64\\bin、约1.5小时、932MB 采用了qt5mingw810_64.cmd、采用了mingw32-make -j24 build文件约2.52GB，已删除 未编译doc 存档：7z(9-极限压缩） 备注 qt-everywhere-opensource-src-5.15.11.zip用D:\\Qt\\Tools\\mingw1120_64\\bin编译，实测报错 ","date":"2023-11-24T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-qt5compile-mingw-w64/","title":"Qt5编译(MinGW-w64)"},{"content":"参考资料 https://doc.qt.io/qt-5/windows-building.html https://doc-snapshots.qt.io/qt5-5.15/windows-building.html https://doc.qt.io/qt-5/supported-platforms.html https://doc.qt.io/qt-5/windows.html https://doc.qt.io/qt-5/windows-requirements.html https://doc.qt.io/qt-5/configure-options.html https://wiki.qt.io/Building_Qt_5_from_Git https://wiki.qt.io/MinGW-64-bit https://blog.csdn.net/zxjohnson/article/details/106621457 (Qt 5.15.0编译指南) https://blog.csdn.net/MrTsai_cpp/article/details/115175669 (Qt 5.15的源码编译(Windows)) https://www.cnblogs.com/arxive/p/14412614.html (QT 5.15 及以后QT版本源码编译（静态库、动态库）) https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) 下载源码包 https://download.qt.io/archive/qt/5.15/5.15.11/single/qt-everywhere-opensource-src-5.15.11.zip 安装build工具并配置相关环境变量 Visual Studio 2019或2022 These tools are not needed to run Qt 5 applications, but they are required for building Qt 5 from source. Perl - Install a recent version of perl (for instance (https://strawberryperl.com/) and add the installation location to your PATH. Python - Install Python from the here and add the installation location to your PATH. 验证build工具是否正确安装 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot; 输入 1 2 Perl -V python -V 设定文件夹 F:\\Qt\\5.5.11\\src 源码目录qt-everywhere-opensource-src-5.15.11.zip解压，并改名为src，放置于F:\\Qt\\5.5.11\\src F:\\Qt\\5.5.11\\build-msvc2019_64 build目录 F:\\Qt\\5.5.11-static\\msvc2019_64 最后安装目录 编译 建立F:\\Qt\\qt5vars.cmd文件，需设置好VS2022的bat路径(x64 Native Tools Command Prompt for VS 2022)、是否amd64、Qt源代码路径\n建立cmd链接cmd-qt5vars，并运行\n本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-msvc2019_64 依上述定位到F:\\Qt\\5.15.11\\build-msvc2019_64 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\msvc2019_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource jom #按官方文档安装jom(是nmake的克隆，支持并行执行多个独立命令类似于GNU make的-j命令) jom install 编译(此段内容为历史记录，作废) 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot;\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt5vars.cmd文件，需设置好VS2022的bat路径、是否amd64、Qt源代码路径 建立cmd链接cmd-qt5vars，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 替代下文手动将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\5.15.11\\build-msvc2019_64 依上述定位到F:\\Qt\\5.15.11\\build-msvc2019_64 依次执行命令\n1 2 3 4 #当使用上述qt5vars.cmd文件时，可省略此三行命令，因为已经在qt5vars.cmd文件中执行 SET _ROOT=F:\\Qt\\5.15.11\\src SET PATH=%_ROOT%\\qtbase\\bin;%_ROOT%\\gnuwin32\\bin;%PATH% SET _ROOT= 1 2 3 4 5 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\5.15.11-static\\msvc2019_64\u0026#34; -debug-and-release -nomake examples -nomake tests -skip qtwebengine -opensource nmake #2023-11-23实测较慢，可按官方文档安装jom(是nmake的克隆，支持并行执行多个独立命令类似于GNU make的-j命令)，此步改为 #jom nmake install #如上一步执行jom，此步应对应执行 #jom install 说明1 -static就是静态编译的意思， -debug-and-release，则表示将调试版、发行版都进行编译。 -prefix 指定安装将会部署的位置，根据自己情况修改 -nomake examples 不需要编译示例 -nomake tests 不需要编译测试工程 -skip qtwebengine 暂时先不编译webengine模块，因为太大了 -opensource 开源版本 -confirm-license 是为了自动确认开源证书，免得到时暂停手动确认 -qt-zlib -ssl -icu 指示检测这些库，并在需要时使用 -opengl desktop 明确指示使用你windows上安装的opengl驱动来编译程序，但这样编译出的程序在别的电脑上运行时需要目标电脑上安装的opengl驱动能兼容你的程序 -platform win32-g++ 指明编译平台是windows，并使用mingw编译器 For Windows machines, either MinGW or Visual Studio toolchains can be used to compile Qt. 1 2 configure.bat -platform win32-g++ configure.bat -platform win32-msvc 说明2 等待配置完成后(其间要输入y同意协议)，再运行命令nmake jom开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令nmake install jom install即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹。 2023-11-23编译 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约1小时、1.58GB（有部分编译错误） build文件约8.2GB，已删除 未编译doc 2023-11-24编译 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约15分钟、4.14GB 采用了qt5vars.cmd、采用了jom和jom install build文件约24GB，已删除 未编译doc 存档：7z(9-极限压缩） ","date":"2023-11-24T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-qt5compile-msvc/","title":"Qt5编译(MSVC)"},{"content":"参考资料 https://doc.qt.io/qt-6.5/windows-building.html https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) https://zhuanlan.zhihu.com/p/630112083 (QT6 opensource安装详解) 下载源码包 https://download.qt.io/archive/qt/6.5/6.5.3/single/qt-everywhere-src-6.5.3.zip 安装build工具并配置相关环境变量 D:\\Qt\\Tools\\mingw1120_64\\bin CMake\tVersion 3.16 and newer (3.17 and newer for builds 3.21 and newer for builds) Ninja Python\tVersion 3\tRequired build tool. Windows installers are available on python.org, or from the Microsoft Store. 验证build工具是否正确安装 打开cmd(不要关闭) 输入 1 2 3 4 5 6 set PATH=D:\\Qt\\Tools\\mingw1120_64\\bin;%PATH% gcc -v g++ -v cmake --version ninja --version python -V 设定文件夹 F:\\Qt\\6.5.3\\src 源码目录qt-everywhere-src-6.5.3.zip解压，并改名为src，放置于F:\\Qt\\6.5.3\\src F:\\Qt\\6.5.3\\build-mingw_64 build目录(Release版本) F:\\Qt\\6.5.3\\build-mingw_64 build目录(Debug版本) F:\\Qt\\6.5.3-static\\mingw_64 最后安装目录(Release版本) F:\\Qt\\6.5.3-static\\mingw_64d 最后安装目录(Debug版本) 编译Release版本 建立F:\\Qt\\qt6mingw_64.cmd文件，需设置好Qt源代码路径、mingw1120_64路径(D:\\Qt\\Tools\\mingw1120_64\\bin)\n建立cmd链接cmd-qt6mingw_64，并运行\n本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-mingw_64 依上述定位到F:\\Qt\\6.5.3\\build-mingw_64\n依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\mingw_64\u0026#34; -release -DNDEBUG #-DNDEBUG见常见错误 cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译Debug版本 关闭上述命令窗口，重新运行cmd链接cmd-qt6mingw_64 输入 1 2 F: cd Qt\\6.5.3\\build-mingw_64d #注意路径有d 依上述定位到F:\\Qt\\6.5.3\\build-mingw_64d 依次执行命令 1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\mingw_64d\u0026#34; -debug -DNDEBUG #注意路径有d，编译选项为-debug，-DNDEBUG见常见错误 cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译(此段内容为历史记录，作废) 在cmd中(上述不要关闭，否则要重新set PATH=D:\\Qt\\Tools\\mingw1120_64\\bin;%PATH%)\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt6mingw_64.cmd文件，需设置好Qt源代码路径、mingw1120_64路径 建立cmd链接cmd-qt6mingw_64，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-mingw_64 依上述定位到F:\\Qt\\6.5.3\\build-mingw_64\n依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\mingw_64\u0026#34; -debug-and-release -DNDEBUG #见常见错误 cmake --build . #不要忘记点 cmake --install . #不要忘记点 说明 其中-static就是静态编译的意思，而后面的-debug-and-release，则表示将调试版、发行版都进行编译。 等待配置完成后，再运行命令cmake \u0026ndash;build .开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令cmake \u0026ndash;install .即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹，释放110多G的空间，它已经没用了。 常见错误 ERROR: Exactly one of NDEBUG and _DEBUG needs to be defined 在configure.bat这个命令中，增加-DNDEBUG 1 E:\\qt-everywhere-src-6.5.0\\qtbase\\configure.bat -top-level -release -no-pch -prefix \u0026#34;E:\\Qt\\Qt6.5.0\u0026#34; -skip qtwebengine -nomake tools -nomake tests -nomake examples -DNDEBUG 2023-11-23编译(已删除) 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw1120_64\\bin、约20分钟、2.0GB build文件夹约100多GB，已删除 测试时程序无法Debug：带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 2023-11-25编译 环境：YPR-Desktop、Windows 11 pro 23H2、D:\\Qt\\Tools\\mingw1120_64\\bin、约15分钟(单独Release或Debug)、Release1.96GB+Debug37.9GB 采用了cmd-qt6mingw_64，分别编译Release和Debug版本 build文件夹：Release55.8GB+Debug120GB，已删除 存档：7z(9-极限压缩） ","date":"2023-11-24T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-qt6compile-mingw-w64/","title":"Qt6编译(MinGW-w64)"},{"content":"参考资料 https://doc.qt.io/qt-6.5/windows-building.html https://www.kucoding.com/article/149 (Qt6.5.3静态编译与使用-酷编程) https://blog.csdn.net/weixin_50964512/article/details/124746458 (Qt 静态编译与使用（6.2 详解版）) 下载源码包 https://download.qt.io/archive/qt/6.5/6.5.3/single/qt-everywhere-src-6.5.3.zip 安装build工具并配置相关环境变量 Visual Studio 2019或2022 CMake\tVersion 3.16 and newer (3.17 and newer for builds 3.21 and newer for builds) Ninja Python\tVersion 3\tRequired build tool. Windows installers are available on python.org, or from the Microsoft Store. 验证build工具是否正确安装 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot; 输入 1 2 3 cmake --version ninja --version python -V 设定文件夹 F:\\Qt\\6.5.3\\src 源码目录qt-everywhere-src-6.5.3.zip解压，并改名为src，放置于F:\\Qt\\6.5.3\\src F:\\Qt\\6.5.3\\build-msvc2019_64 build目录(Release版本) F:\\Qt\\6.5.3\\build-msvc2019_64d build目录(Debug版本) F:\\Qt\\6.5.3-static\\msvc2019_64 最后安装目录(Release版本) F:\\Qt\\6.5.3-static\\msvc2019_64d 最后安装目录(Debug版本) 编译Release版本 建立F:\\Qt\\qt6vars.cmd文件，需设置好VS2022的bat路径(x64 Native Tools Command Prompt for VS 2022)、是否amd64、Qt源代码路径\n建立cmd链接cmd-qt6vars，并运行\n本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-msvc2019_64 依上述定位到F:\\Qt\\6.5.3\\build-msvc2019_64 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64\u0026#34; -release cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译Debug版本 关闭上述命令窗口，重新运行cmd链接cmd-qt6vars\n输入\n1 2 F: cd Qt\\6.5.3\\build-msvc2019_64d #注意路径有d 依上述定位到F:\\Qt\\6.5.3\\build-msvc2019_64d 依次执行命令\n1 2 3 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64d\u0026#34; -debug #注意路径有d，编译选项为-debug cmake --build . #不要忘记点 cmake --install . #不要忘记点 编译(此段内容为历史记录，作废) 打开\u0026quot;x64 Native Tools Command Prompt for VS 2022\u0026quot;\n本步骤在2023-11-23编译时未使用，查看官网文档可将上一步替换优化如下\n建立F:\\Qt\\qt6vars.cmd文件，需设置好VS2022的bat路径、是否amd64、Qt源代码路径 建立cmd链接cmd-qt6vars，并运行 比较后，本步骤主要用途为 开启cmd.exe /E:ON /V:ON 将Qt源码相关路径加入PATH /E:ON 启用命令扩展 详见[cmd.exe启动参数说明] /V:ON 启用延迟的环境变量扩展 输入\n1 2 F: cd Qt\\6.5.3\\build-msvc2019_64 依上述定位到F:\\Qt\\6.5.3\\build-msvc2019_64 依次执行命令\n1 2 3 4 #2023-11-23编译、2023-11-24编译 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64\u0026#34; -debug-and-release cmake --build . #不要忘记点 cmake --install . #不要忘记点 2023-11-24编译解决带d版本在camke \u0026ndash;install .时没有被复制过来\n清空build目录，最后安装目录不动\n依次执行命令\n1 2 3 4 #重新用-debug编译一次 ..\\src\\configure.bat -static -prefix \u0026#34;F:\\Qt\\6.5.3-static\\msvc2019_64\u0026#34; -debug cmake --build . #不要忘记点 cmake --install . #不要忘记点 说明 其中-static就是静态编译的意思，而后面的-debug-and-release，则表示将调试版、发行版都进行编译。 等待配置完成后，再运行命令cmake \u0026ndash;build .开始构建： 然后就是慢慢等编译了，这个过程比较漫长，如果电脑配置较低，估计需要几个小时： 编译完成后，继续运行命令cmake \u0026ndash;install .即可将编译好的静态库安装到前面我们所指定的目录中去： 此时你就可以删除前面的build文件夹，释放110多G的空间，它已经没用了。 2023-11-23编译(已删除) 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约20分钟、1.41GB build文件夹约100多GB，已删除 测试时程序无法Debug：带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 2023-11-24编译 环境：YPR-Desktop、Windows 11 pro 23H2、Visual Studio 2022、约20分钟、Release1.41GB+Debug15.6GB 采用了qt6vars.cmd build文件夹约111GB（单独Release为51.3GB，单独Debug为77.9GB），已删除 测试时程序无法Debug：带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 解决方案：用-debug选项再编译一次（build文件夹需清空，install文件夹需备份Release版本） -debug和\u0026ndash;release选项有同名文件但大小不同，install文件夹不能合并 Debug版本QTDIR路径不是F:\\Qt\\6.5.3\\build-msvc2019_64d而是F:\\Qt\\6.5.3\\build-msvc2019_64，应用qt.conf修正 存档：7z(9-极限压缩） ","date":"2023-11-24T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-qt6compile-msvc/","title":"Qt6编译(MSVC)"},{"content":"Qt6-静态库测试 Qt6.5.3-static-mingw1120_64-Release（天远编译2023-11-25） Release：正常 Debug： 正常 Qt6.5.3-static-mingw1120_64-Debug（天远编译2023-11-25） Release：正常 Debug： exe文件有713MB Qt6.5.3-static-msvc2019_64-Release（天远编译2023-11-24） Release：正常 Debug： error: dependent \u0026lsquo;F:\\Qt\\6.5.3-static\\msvc2019_64\\lib\\Qt6Widgetsd.lib\u0026rsquo; does not exist. Qt6.5.3-static-msvc2019_64-Debug（天远编译2023-11-24） Release：error: dependent \u0026lsquo;F:\\Qt\\6.5.3-static\\msvc2019_64d\\lib\\Qt6Widgets.lib\u0026rsquo; does not exist. Debug：正常 Qt6.5.3-static-mingw1120_64（天远编译2023-11-23） Release：正常 Debug： error: No rule to make target \u0026lsquo;F:/Qt/6.5.3-static/mingw_64/lib/libQt6Widgetsd.a\u0026rsquo;, needed by \u0026lsquo;debug/samp2_2.exe\u0026rsquo;. Stop. 原因为带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 解决方案：用-debug选项再编译一次 Qt6.5.3-static-msvc2019_64（天远编译2023-11-23） Release：正常 Debug：error: dependent \u0026lsquo;F:\\Qt\\6.5.3-static\\msvc2019_64\\lib\\Qt6Widgetsd.lib\u0026rsquo; does not exist. 原因为带d版本在build文件夹中已编译，但在camke \u0026ndash;install .时没有被复制过来，参考VS2022编译安装Qt6.4 解决方案：用-debug选项再编译一次 Qt6.5.2-static-mingw1320_64（MSYS2-UCRT64） Release： error: cannot find -lb2: No such file or directory error: collect2.exe: error: ld returned 1 exit status error: [Makefile.Release:74: release/Test.exe] Error 1 也报过77 Debug：同上 Qt5-静态库测试 Qt5.15.11-static-mingw810_64（天远编译2023-11-24） Release：正常 Debug：exe文件有691MB（是-debug-and-release的原因，如果只-release可解决问题） Qt5.15.11-static-mingw810_64-Release（天远编译2023-11-28 YPR-Desktop） Release：正常 Debug：正常 Qt5.15.11-static-mingw810_64-Release（天远编译2023-11-28 YPR-Server） Release：正常 Debug：正常 Qt5.15.11-static-msvc2019_64（天远编译2023-11-24） Release：exe文件大小正常\nDebug：exe文件大小正常\n两种模式都有以下问题\nwarning: C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失 error: C2001: 常量中有换行符 error: C2146: 语法错误: 缺少“)”(在标识符“ui”的前面) 解决方案在pro文件中加入QMAKE_CXXFLAGS += /utf-8，参考资料：彻底解决Qt中文乱码以及汉字编码的问题(UTF-8/GBK)\nQt5.15.10-static-mingw1320_64（MSYS2-UCRT64） Release：正常\nDbug：正常\n","date":"2023-11-24T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/prog/cpp-qt-test-static/","title":"测试Qt静态库"},{"content":"天远网站体系-自建 天远网站：http://www.yprnet.com (自建HTML+CSS+Javascript体系)目前托管于 GitHub Pages 天远网站：http://www.yuanpeirong.com (自建HTML+CSS+Javascript体系) 目前托管于 七牛云存储 天远博客体系-自建网站子博客 天远博客：http://www.yprnet.com/blog (由 hexo 编译)\u0026mdash;准备切换为 hugo 天远博客：http://www.yuanpeirong.com/blog (由 hexo 编译)\u0026mdash;准备切换为 hugo 天远博客体系-自建博客 天远博客：https://blog.yprnet.com (由 hugo 编译) 目前托管于 Github Pages 天远博客：http://blog.yuanpeirong.com (由 hugo 编译) 目前托管于 Gitee Pages (隐性转发) 天远博客：https://ypr.gitee.io (由 hugo 编译) 目前托管于 Gitee Pages 天远博客：https://www.yprnet.cc (由 hugo 编译) 目前托管于 Github Pages 天远博客体系-公共博客 永远的荣-腾讯博客：暂不公开 永远的荣的博客：http://blog.sina.com.cn/yprymxhl 搭建于 新浪博客 (停止服务) 开源中国(技术)：http://my.oschina.net/u/186539/blog 搭建于 开源中国 博客园(技术)：https://www.cnblogs.com/yuanpeirong/ 搭建于 博客园 CSDN(技术)：https://blog.csdn.net/yuanpeirong 搭建于 CSDN Lofter(技术)：http://tysoft.lofter.com/ 搭建于 网易Lofter 腾讯云社区(在建中) 云栖社区(在建中)：https://yq.aliyun.com/u/yuanpeirong 搭建于 云栖社区 简书(在建中) 更新记录 2024-01-07：\nblog.yprnet.com托管由Gitee改为Github，启用https 新增www.yprnet.cc的说明 删除托管于CODING的blog3.yuanpeirong.com blog.sina.com.cn/yprymxhl因新浪停止服务，做删除标识 2020-03-18：\nblog.yuanpeirong.com改为托管于码云 原托管于CODING的天远博客更改域名为：blog3.yuanpeirong.com 建立blog.yprnet.com，托管于码云 2020-02-27：\n建立文章《天远网站、博客体系》 ","date":"2020-02-27T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/tyblog/","title":"天远网站、博客体系"},{"content":"\u0026laquo; 访问 Wow!Ubuntu\n声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里」\u0026ndash;By @riku\n注： 本项目托管于 GitHub上，请通过\u0026quot;派生\u0026quot;和\u0026quot;合并请求\u0026quot;来帮忙改进本项目。\nMarkdown: Basics （快速入门） / (点击查看完整语法说明) Getting the Gist of Markdown\u0026rsquo;s Formatting Syntax 此页提供了 Markdown 的简单概念， 语法说明 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。\n其实直接试试看也是一个很不错的方法， Dingus 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。\n段落、标题、区块代码 一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。\nMarkdown 支持两种标题的语法，[Setext] 1 和 [atx] 2 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。\n区块引用则使用 email 形式的 \u0026lsquo;\u0026gt;\u0026rsquo; 角括号。\nMarkdown 语法:\nA First Level Header ==================== A Second Level Header --------------------- Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog's back. ### Header 3 \u0026gt; This is a blockquote. \u0026gt; \u0026gt; This is the second paragraph in the blockquote. \u0026gt; \u0026gt; ## This is an H2 in a blockquote 输出 HTML 为：\n\u0026lt;h1\u0026gt;A First Level Header\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;A Second Level Header\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;The quick brown fox jumped over the lazy dog's back.\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;Header 3\u0026lt;/h3\u0026gt; \u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt;This is a blockquote.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;This is the second paragraph in the blockquote.\u0026lt;/p\u0026gt; \u0026lt;h2\u0026gt;This is an H2 in a blockquote\u0026lt;/h2\u0026gt; \u0026lt;/blockquote\u0026gt; 修辞和强调 Markdown 使用星号和底线来标记需要强调的区段。\nMarkdown 语法:\nSome of these words *are emphasized*. Some of these words _are emphasized also_. Use two asterisks for **strong emphasis**. Or, if you prefer, __use two underscores instead__. 输出 HTML 为:\n\u0026lt;p\u0026gt;Some of these words \u0026lt;em\u0026gt;are emphasized\u0026lt;/em\u0026gt;. Some of these words \u0026lt;em\u0026gt;are emphasized also\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Use two asterisks for \u0026lt;strong\u0026gt;strong emphasis\u0026lt;/strong\u0026gt;. Or, if you prefer, \u0026lt;strong\u0026gt;use two underscores instead\u0026lt;/strong\u0026gt;.\u0026lt;/p\u0026gt; 列表 无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：\n* Candy. * Gum. * Booze. 加号：\n+ Candy. + Gum. + Booze. 和减号\n- Candy. - Gum. - Booze. 都会输出 HTML 为：\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Candy.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Gum.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Booze.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记：\n1. Red 2. Green 3. Blue 输出 HTML 为：\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Red\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Green\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Blue\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 如果你在项目之间插入空行，那项目的内容会用 \u0026lt;p\u0026gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。\n* A list item. With multiple paragraphs. * Another item in the list. 输出 HTML 为：\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;A list item.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;With multiple paragraphs.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Another item in the list.\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 链接 Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。\n行内形式是直接在后面用括号直接接上链接：\nThis is an [example link](http://example.com/). 输出 HTML 为：\n\u0026lt;p\u0026gt;This is an \u0026lt;a href=\u0026quot;http://example.com/\u0026quot;\u0026gt; example link\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; 你也可以选择性的加上 title 属性：\nThis is an [example link](http://example.com/ \u0026quot;With a Title\u0026quot;). 输出 HTML 为：\n\u0026lt;p\u0026gt;This is an \u0026lt;a href=\u0026quot;http://example.com/\u0026quot; title=\u0026quot;With a Title\u0026quot;\u0026gt; example link\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：\nI get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ \u0026quot;Google\u0026quot; [2]: http://search.yahoo.com/ \u0026quot;Yahoo Search\u0026quot; [3]: http://search.msn.com/ \u0026quot;MSN Search\u0026quot; 输出 HTML 为：\n\u0026lt;p\u0026gt;I get 10 times more traffic from \u0026lt;a href=\u0026quot;http://google.com/\u0026quot; title=\u0026quot;Google\u0026quot;\u0026gt;Google\u0026lt;/a\u0026gt; than from \u0026lt;a href=\u0026quot;http://search.yahoo.com/\u0026quot; title=\u0026quot;Yahoo Search\u0026quot;\u0026gt;Yahoo\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://search.msn.com/\u0026quot; title=\u0026quot;MSN Search\u0026quot;\u0026gt;MSN\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：\nI start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: http://www.nytimes.com/ 输出 HTML 为：\n\u0026lt;p\u0026gt;I start my morning with a cup of coffee and \u0026lt;a href=\u0026quot;http://www.nytimes.com/\u0026quot;\u0026gt;The New York Times\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; 图片 图片的语法和链接很像。\n行内形式（title 是选择性的）：\n![alt text](/path/to/img.jpg \u0026quot;Title\u0026quot;) 参考形式：\n![alt text][id] [id]: /path/to/img.jpg \u0026quot;Title\u0026quot; 上面两种方法都会输出 HTML 为：\n\u0026lt;img src=\u0026quot;/path/to/img.jpg\u0026quot; alt=\u0026quot;alt text\u0026quot; title=\u0026quot;Title\u0026quot; /\u0026gt; 代码 在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 \u0026amp;、\u0026lt; 和 \u0026gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：\nI strongly recommend against using any `\u0026lt;blink\u0026gt;` tags. I wish SmartyPants used named entities like `\u0026amp;mdash;` instead of decimal-encoded entites like `\u0026amp;#8212;`. 输出 HTML 为：\n\u0026lt;p\u0026gt;I strongly recommend against using any \u0026lt;code\u0026gt;\u0026amp;lt;blink\u0026amp;gt;\u0026lt;/code\u0026gt; tags.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;I wish SmartyPants used named entities like \u0026lt;code\u0026gt;\u0026amp;amp;mdash;\u0026lt;/code\u0026gt; instead of decimal-encoded entites like \u0026lt;code\u0026gt;\u0026amp;amp;#8212;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 \u0026amp;、\u0026lt; 和 \u0026gt; 也一样会自动转成 HTML 实体。\nMarkdown 语法:\nIf you want your page to validate under XHTML 1.0 Strict, you've got to put paragraph tags in your blockquotes: \u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt;For example.\u0026lt;/p\u0026gt; \u0026lt;/blockquote\u0026gt; 输出 HTML 为：\n\u0026lt;p\u0026gt;If you want your page to validate under XHTML 1.0 Strict, you've got to put paragraph tags in your blockquotes:\u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;blockquote\u0026amp;gt; \u0026amp;lt;p\u0026amp;gt;For example.\u0026amp;lt;/p\u0026amp;gt; \u0026amp;lt;/blockquote\u0026amp;gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; ","date":"2020-02-25T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/soft/notes-markdown-basics/","title":"Markdown Basics （快速入门）"},{"content":"\u0026laquo; 访问 Wow!Ubuntu\nNOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax.\n声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里 。」\u0026ndash;By @riku\n注： 本项目托管于 GitHub上，请通过\u0026quot;派生\u0026quot;和\u0026quot;合并请求\u0026quot;来帮忙改进本项目。\nMarkdown 语法说明 (简体中文版) / (点击查看快速入门) 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 概述 宗旨 Markdown 的目标是实现「易读易写」。\n可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext] 1、[atx] 2、[Textile] 3、[reStructuredText] 4、[Grutatext] 5 和 [EtText] 6，而最大灵感来源其实是纯文本电子邮件的格式。\n总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。\n兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。\nMarkdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\n要制约的只有一些 HTML 区块元素――比如 \u0026lt;div\u0026gt;、\u0026lt;table\u0026gt;、\u0026lt;pre\u0026gt;、\u0026lt;p\u0026gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 \u0026lt;p\u0026gt; 标签。\n例子如下，在 Markdown 文件里加上一段 HTML 表格：\n这是一个普通段落。 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Foo\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。\nHTML 的区段（行内）标签如 \u0026lt;span\u0026gt;、\u0026lt;cite\u0026gt;、\u0026lt;del\u0026gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 \u0026lt;a\u0026gt; 或 \u0026lt;img\u0026gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： \u0026lt; 和 \u0026amp; 。 \u0026lt; 符号用于起始标签，\u0026amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 \u0026amp;lt; 和 \u0026amp;amp;。\n\u0026amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT\u0026amp;T」 ，你必须要写成「AT\u0026amp;amp;T」。而网址中的 \u0026amp; 字符也要转换。比如你要链接到：\nhttp://images.google.com/images?num=30\u0026amp;q=larry+bird 你必须要把网址转换写为：\nhttp://images.google.com/images?num=30\u0026amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。\nMarkdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 \u0026amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 \u0026amp;amp;。\n所以你如果要在文档中插入一个版权符号 ©，你可以这样写：\n\u0026amp;copy; Markdown 会保留它不动。而若你写：\nAT\u0026amp;T Markdown 就会将它转为：\nAT\u0026amp;amp;T 类似的状况也会发生在 \u0026lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 \u0026lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：\n4 \u0026lt; 5 Markdown 将会把它转换为：\n4 \u0026amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， \u0026lt; 和 \u0026amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 \u0026lt; 和 \u0026amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）\n区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 \u0026lt;br /\u0026gt; 标签。\n如果你确实想要依赖 Markdown 来插入 \u0026lt;br /\u0026gt; 标签的话，在插入处先按入两个以上的空格然后回车。\n的确，需要多费点事（多加空格）来产生 \u0026lt;br /\u0026gt; ，但是简单地「每个换行都转换为 \u0026lt;br /\u0026gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。\n标题 Markdown 支持两种标题的语法，类 [Setext] 1 和类 [atx] 2 形式。\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\nThis is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\n# 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\n# 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 \u0026gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 \u0026gt; ：\n\u0026gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, \u0026gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. \u0026gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. \u0026gt; \u0026gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse \u0026gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt; ：\n\u0026gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. \u0026gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 \u0026gt; ：\n\u0026gt; This is the first level of quoting. \u0026gt; \u0026gt; \u0026gt; This is nested blockquote. \u0026gt; \u0026gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n\u0026gt; ## 这是一个标题。 \u0026gt; \u0026gt; 1. 这是第一行列表项。 \u0026gt; 2. 这是第二行列表项。 \u0026gt; \u0026gt; 给出一些例子代码： \u0026gt; \u0026gt; return shell_exec(\u0026quot;echo $input | $markdown_script\u0026quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。\n列表 Markdown 支持有序列表和无序列表。\n无序列表使用星号、加号或是减号作为列表标记：\n* Red * Green * Blue 等同于：\n+ Red + Green + Blue 也等同于：\n- Red - Green - Blue 有序列表则使用数字接着一个英文句点：\n1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Bird\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;McHale\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Parish\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; 如果你的列表标记写成：\n1. Bird 1. McHale 1. Parish 或甚至是：\n3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\n如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：\n* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行：\n* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 \u0026lt;p\u0026gt; 标签包起来，举例来说：\n* Bird * Magic 会被转换为：\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Bird\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Magic\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 但是这个：\n* Bird * Magic 会被转换为：\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Bird\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Magic\u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\n* This is a list item with two paragraphs. This is the second paragraph in the list item. You're only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 \u0026gt; 就需要缩进：\n* A list item with a blockquote: \u0026gt; This is a blockquote \u0026gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：\n* 一列表项包含一个列表区块： \u0026lt;代码写在这\u0026gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法：\n1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。\n1986\\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 \u0026lt;pre\u0026gt; 和 \u0026lt;code\u0026gt; 标签来把代码区块包起来。\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n这是一个普通段落： 这是一个代码区块。 Markdown 会转换成：\n\u0026lt;p\u0026gt;这是一个普通段落：\u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;这是一个代码区块。 \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：\nHere is an example of AppleScript: tell application \u0026quot;Foo\u0026quot; beep end tell 会被转换为：\n\u0026lt;p\u0026gt;Here is an example of AppleScript:\u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;tell application \u0026quot;Foo\u0026quot; beep end tell \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n在代码区块里面， \u0026amp; 、 \u0026lt; 和 \u0026gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：\n\u0026lt;div class=\u0026quot;footer\u0026quot;\u0026gt; \u0026amp;copy; 2004 Foo Corporation \u0026lt;/div\u0026gt; 会被转换为：\n\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026amp;lt;div class=\u0026quot;footer\u0026quot;\u0026amp;gt; \u0026amp;amp;copy; 2004 Foo Corporation \u0026amp;lt;/div\u0026amp;gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。\n分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n* * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\nThis is [an example](http://example.com/ \u0026quot;Title\u0026quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生：\n\u0026lt;p\u0026gt;This is \u0026lt;a href=\u0026quot;http://example.com/\u0026quot; title=\u0026quot;Title\u0026quot;\u0026gt; an example\u0026lt;/a\u0026gt; inline link.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026quot;http://example.net/\u0026quot;\u0026gt;This link\u0026lt;/a\u0026gt; has no title attribute.\u0026lt;/p\u0026gt; 如果你是要链接到同样主机的资源，你可以使用相对路径：\nSee my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\nThis is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格：\nThis is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n[id]: http://example.com/ \u0026quot;Optional Title Here\u0026quot; 链接内容定义的形式为：\n方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同：\n[foo]: http://example.com/ \u0026quot;Optional Title Here\u0026quot; [foo]: http://example.com/ 'Optional Title Here' [foo]: http://example.com/ (Optional Title Here) **请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\n链接网址也可以用尖括号包起来：\n[id]: \u0026lt;http://example.com/\u0026gt; \u0026quot;Optional Title Here\u0026quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\n[id]: http://example.com/longish/path/to/resource/here \u0026quot;Optional Title Here\u0026quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：\n[link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \u0026ldquo;Google\u0026rdquo; 链接到 google.com，你可以简化成：\n[Google][] 然后定义链接内容：\n[Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\nVisit [Daring Fireball][] for more information. 然后接着定义链接：\n[Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\n下面是一个参考式链接的范例：\nI get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ \u0026quot;Google\u0026quot; [2]: http://search.yahoo.com/ \u0026quot;Yahoo Search\u0026quot; [3]: http://search.msn.com/ \u0026quot;MSN Search\u0026quot; 如果改成用链接名称的方式写：\nI get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ \u0026quot;Google\u0026quot; [yahoo]: http://search.yahoo.com/ \u0026quot;Yahoo Search\u0026quot; [msn]: http://search.msn.com/ \u0026quot;MSN Search\u0026quot; 上面两种写法都会产生下面的 HTML。\n\u0026lt;p\u0026gt;I get 10 times more traffic from \u0026lt;a href=\u0026quot;http://google.com/\u0026quot; title=\u0026quot;Google\u0026quot;\u0026gt;Google\u0026lt;/a\u0026gt; than from \u0026lt;a href=\u0026quot;http://search.yahoo.com/\u0026quot; title=\u0026quot;Yahoo Search\u0026quot;\u0026gt;Yahoo\u0026lt;/a\u0026gt; or \u0026lt;a href=\u0026quot;http://search.msn.com/\u0026quot; title=\u0026quot;MSN Search\u0026quot;\u0026gt;MSN\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\nI get 10 times more traffic from [Google](http://google.com/ \u0026quot;Google\u0026quot;) than from [Yahoo](http://search.yahoo.com/ \u0026quot;Yahoo Search\u0026quot;) or [MSN](http://search.msn.com/ \u0026quot;MSN Search\u0026quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\n使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\n强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 \u0026lt;em\u0026gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 \u0026lt;strong\u0026gt;，例如：\n*single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成：\n\u0026lt;em\u0026gt;single asterisks\u0026lt;/em\u0026gt; \u0026lt;em\u0026gt;single underscores\u0026lt;/em\u0026gt; \u0026lt;strong\u0026gt;double asterisks\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;double underscores\u0026lt;/strong\u0026gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。\n强调也可以直接插在文字中间：\nun*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\\*this text is surrounded by literal asterisks\\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：\nUse the `printf()` function. 会产生：\n\u0026lt;p\u0026gt;Use the \u0026lt;code\u0026gt;printf()\u0026lt;/code\u0026gt; function.\u0026lt;/p\u0026gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n``There is a literal backtick (`) here.`` 这段语法会产生：\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;There is a literal backtick (`) here.\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：\nA single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生：\n\u0026lt;p\u0026gt;A single backtick in a code span: \u0026lt;code\u0026gt;`\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;A backtick-delimited string in a code span: \u0026lt;code\u0026gt;`foo`\u0026lt;/code\u0026gt;\u0026lt;/p\u0026gt; 在代码区段内，\u0026amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：\nPlease don't use any `\u0026lt;blink\u0026gt;` tags. 转为：\n\u0026lt;p\u0026gt;Please don't use any \u0026lt;code\u0026gt;\u0026amp;lt;blink\u0026amp;gt;\u0026lt;/code\u0026gt; tags.\u0026lt;/p\u0026gt; 你也可以这样写：\n`\u0026amp;#8212;` is the decimal-encoded equivalent of `\u0026amp;mdash;`. 以产生：\n\u0026lt;p\u0026gt;\u0026lt;code\u0026gt;\u0026amp;amp;#8212;\u0026lt;/code\u0026gt; is the decimal-encoded equivalent of \u0026lt;code\u0026gt;\u0026amp;amp;mdash;\u0026lt;/code\u0026gt;.\u0026lt;/p\u0026gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。\n行内式的图片语法看起来像是：\n![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg \u0026quot;Optional title\u0026quot;) 详细叙述如下：\n一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 \u0026rsquo;title\u0026rsquo; 文字。 参考式的图片语法则长得像这样：\n![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n[id]: url/to/image \u0026quot;Optional title attribute\u0026quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 \u0026lt;img\u0026gt; 标签。\n其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\u0026lt;http://example.com/\u0026gt; Markdown 会转为：\n\u0026lt;a href=\u0026quot;http://example.com/\u0026quot;\u0026gt;http://example.com/\u0026lt;/a\u0026gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：\n\u0026lt;address@example.com\u0026gt; Markdown 会转成：\n\u0026lt;a href=\u0026quot;\u0026amp;#x6D;\u0026amp;#x61;i\u0026amp;#x6C;\u0026amp;#x74;\u0026amp;#x6F;:\u0026amp;#x61;\u0026amp;#x64;\u0026amp;#x64;\u0026amp;#x72;\u0026amp;#x65; \u0026amp;#115;\u0026amp;#115;\u0026amp;#64;\u0026amp;#101;\u0026amp;#120;\u0026amp;#x61;\u0026amp;#109;\u0026amp;#x70;\u0026amp;#x6C;e\u0026amp;#x2E;\u0026amp;#99;\u0026amp;#111; \u0026amp;#109;\u0026quot;\u0026gt;\u0026amp;#x61;\u0026amp;#x64;\u0026amp;#x64;\u0026amp;#x72;\u0026amp;#x65;\u0026amp;#115;\u0026amp;#115;\u0026amp;#64;\u0026amp;#101;\u0026amp;#120;\u0026amp;#x61; \u0026amp;#109;\u0026amp;#x70;\u0026amp;#x6C;e\u0026amp;#x2E;\u0026amp;#99;\u0026amp;#111;\u0026amp;#109;\u0026lt;/a\u0026gt; 在浏览器里面，这段字串（其实是 \u0026lt;a href=\u0026quot;mailto:address@example.com\u0026quot;\u0026gt;address@example.com\u0026lt;/a\u0026gt;）会变成一个可以点击的「address@example.com」链接。\n（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）\n反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 \u0026lt;em\u0026gt; 标签），你可以在星号的前面加上反斜杠：\n\\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。\n感谢 fenprace，addv。\nMarkdown 免费编辑器 Windows 平台\nMarkdownPad MarkPad Linux 平台\nReText Mac 平台\nMou 在线编辑器\nMarkable.in Dillinger.io 浏览器插件\nMaDe (Chrome) 高级应用\nSublime Text 2 + MarkdownEditing / 教程 *** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！\n","date":"2020-02-25T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/soft/notes-markdown-syntax/","title":"Markdown 语法说明 (简体中文版)"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2010-01-01T13:48:21+08:00","image":"https://www.yprnet.cc/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.yprnet.cc/p/test-chinese/","title":"中文测试"},{"content":"你好，天远博客 这是天远博客的第一篇文章。\n","date":"2010-01-01T13:00:21+08:00","permalink":"https://www.yprnet.cc/p/hello/","title":"你好"}]