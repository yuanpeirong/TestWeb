<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>动态库 on 天远博客</title>
        <link>https://www.yprnet.cc/tags/%E5%8A%A8%E6%80%81%E5%BA%93/</link>
        <description>Recent content in 动态库 on 天远博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>YuanPeirong TianYuan All Rights Reserved.</copyright>
        <lastBuildDate>Thu, 18 Jan 2024 15:00:00 +0800</lastBuildDate><atom:link href="https://www.yprnet.cc/tags/%E5%8A%A8%E6%80%81%E5%BA%93/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>GCC上的动态库与静态库</title>
        <link>https://www.yprnet.cc/p/prog/cpp-gcc-sharedandstaticlib/</link>
        <pubDate>Thu, 18 Jan 2024 15:00:00 +0800</pubDate>
        
        <guid>https://www.yprnet.cc/p/prog/cpp-gcc-sharedandstaticlib/</guid>
        <description>&lt;h2 id=&#34;文件名后缀名&#34;&gt;文件名、后缀名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态链接库文件的后缀名：Linux通常用 &lt;code&gt;.a &lt;/code&gt; ,Windows通常用 &lt;code&gt;.lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;动态链接库文件的后缀名：Linux通常用 &lt;code&gt;.so&lt;/code&gt; ,Windows通常用 &lt;code&gt;.dll&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;库类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Linux-GCC&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Windows-MinGW&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Windows-MSVC&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;静态库&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;libxxx.a&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;libxxx.a&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;xxx.lib&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;动态库&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;libxxx.so&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;libxxx.dll&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;xxx.dll&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;动态库附加文件&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;libxxx.dll.a&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;xxx.lib&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;动态库附加文件&lt;code&gt;libxxx.dll.a&lt;/code&gt;有时会有其他形式：&lt;code&gt;libxxx.a&lt;/code&gt;、&lt;code&gt;libxxxdll.a&lt;/code&gt;，后者改变了库名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建动态库&#34;&gt;创建动态库&lt;/h2&gt;
&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc -fPIC -shared 源文件名(列表)... -o 动态链接库名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcc -fPIC -shared 目标文件名(列表)... -o 动态链接库名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单个源文件目标直接生成动态库&#34;&gt;单个源文件/目标直接生成动态库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;方法1: &lt;code&gt;gcc -fPIC -shared xxx.c -o libxxx.so&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法2: &lt;code&gt;gcc -fPIC -shared xxx.o -o libxxx.so&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多个源文件目标生成动态库&#34;&gt;多个源文件/目标生成动态库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;方法1: &lt;code&gt;gcc -fPIC -shared xxx1.c xxx2.c xxx3.c -o libxxx.so&lt;/code&gt;&lt;br&gt;
或:    &lt;code&gt;gcc -fPIC -shared *.c -o libxxx.so&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法2: &lt;code&gt;gcc -fPIC -shared xxx1.o xxx2.o xxx3.o -o libxxx.so&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;备注&#34;&gt;备注&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libxxx.so&lt;/code&gt;可在Windows上改为&lt;code&gt;libxxx.dll&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;windows上小熊猫c创建的c语言动态库testshared-c&#34;&gt;Windows上小熊猫C++创建的C语言动态库&lt;code&gt;TestShared-C&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gcc.exe -c dllmain.c -o dllmain.o -O2 -pipe -DBUILDING_DLL=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;windres.exe -i TestShared-C_private.rc --input-format=rc -o Test-O coff&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gcc.exe -mdll dllmain.o TestShared-C_private.res -o libTestShared-C.dll -s -static -Wl,--output-def,libTestShared-C.def,--out-implib,libTestShared-C.a&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注：&lt;code&gt;-DBUILDING_DLL=1&lt;/code&gt;是为了让&lt;code&gt;dll.h&lt;/code&gt;中的宏&lt;code&gt;BUILDING_DLL&lt;/code&gt;生效，下同&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;windows上小熊猫c创建的c语言动态库testshared-cpp&#34;&gt;Windows上小熊猫C++创建的C++语言动态库&lt;code&gt;TestShared-CPP&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;g++.exe -c dllmain.cpp -o dllmain.o -O2 -std=c++2a -pipe -DBUILDING_DLL=1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;windres.exe -i TestShared-CPP_private.rc --input-format=rc -o TestShared-CPP_private.res -O coff&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;g++.exe -mdll dllmain.o TestShared-CPP_private.res -o libTestShared-CPP.dll -s -static -Wl,--output-def,libTestShared-CPP.def,--out-implib,libTestShared-CPP.a&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单步：&lt;br&gt;
&lt;code&gt;g++.exe -fPIC -mdll xxx1.c xxx2.c xxx3.c -o libxxx.dll -O2 -std=c++20 -pipe -s -static -Wl,--output-def,libxxx.def,--out-implib,libxxx.dll.a -DXXXXXX=1&lt;/code&gt;&lt;br&gt;
解析：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++.exe -fPIC -mdll xxx1.c xxx2.c xxx3.c -o libxxx.dll&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-O2 -std=c++20 -pipe -s -static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wl,--output-def,libxxx.def,--out-implib,libxxx.dll.a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-DXXXXXX=1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分步：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++.exe -c xxx1.c xxx2.c xxx3.c -O2 -std=c++20 -pipe -DXXXXXX=1&lt;/code&gt;&lt;br&gt;
或&lt;code&gt;g++.exe -c xxx1.c -O2 -o xxx1.o -std=c++20 -pipe -DXXXXXX=1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++.exe -fPIC -mdll xxx1.o xxx2.o xxx3.o -o libxxx.dll -s -static -Wl,--output-def,libxxx.def,--out-implib,libxxx.dll.a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gcc编译选项说明&#34;&gt;gcc编译选项说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;：只编译，不链接，生成目标文件&lt;code&gt;.o&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shared&lt;/code&gt;：用于生成动态链接库（shared library）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mdll&lt;/code&gt;  ：为DLL生成代码(Generate code for a DLL)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-fPIC&lt;/code&gt;：生成位置无关代码，方便动态链接，常用于编译动态链接库（shared library）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wl,&amp;lt;选项&amp;gt;&lt;/code&gt;：将逗号分隔的 &amp;lt;选项&amp;gt; 传递给链接器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--output-def &amp;lt;file&amp;gt;&lt;/code&gt;：产生与导出符号相关的def文件(Generate a .DEF file for the built DLL)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--out-implib FILE&lt;/code&gt;：产生用于提供__img_符号的导入库(Generate import library)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--kill-at&lt;/code&gt;：从导出的符号中删除@nn(Remove @nn from exported symb)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wl,--output-def,libTestShared-CPP.def,--out-implib,libTestShared-CPP.a&lt;/code&gt;中不要有空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建静态库&#34;&gt;创建静态库&lt;/h2&gt;
&lt;h3 id=&#34;格式-1&#34;&gt;格式&lt;/h3&gt;
&lt;p&gt;简单地说，静态库是一个目标文件的简单集合。因此，首先有目标文件。再把生成的目标文件编译为静态库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：先生成.o目标文件&lt;br&gt;
&lt;code&gt;gcc -c 源文件列表&lt;/code&gt;&lt;br&gt;
&lt;code&gt;gcc -c *.c&lt;/code&gt;&lt;br&gt;
如&lt;code&gt;gcc -c myfunc.c myproc.c&lt;/code&gt;将得到&lt;code&gt;myfunc.o&lt;/code&gt;和&lt;code&gt;myproc.o&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第二步：由&lt;code&gt;ar&lt;/code&gt;（archive，归档的意思）把多个目标文件集合起来编译为静态库。&lt;br&gt;
&lt;code&gt;ar rcs 静态链接库名称 目标文件1 目标文件2 ... &lt;/code&gt;&lt;br&gt;
&lt;code&gt;ar rcs libname.a *.o&lt;/code&gt; 或 &lt;code&gt;gcc *.o -static -o libname.a&lt;/code&gt;&lt;br&gt;
如&lt;code&gt;ar rcs libmyjob.a myfunc.o myproc.o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单个源文件目标直接生成静态库&#34;&gt;单个源文件/目标直接生成静态库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正确方法: &lt;code&gt;ar rcs libxxx.a xxx.o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;错误方法: &lt;code&gt;ar rcs libxxx.a xxx.c&lt;/code&gt;（静态库可以生成；当运行连接了该静态库的可执行程序会报错：could not read symbols:Archive has no index;run ranlib to add one）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多个源文件目标生成静态库&#34;&gt;多个源文件/目标生成静态库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正确方法: &lt;code&gt;ar rcs libxxx.a xxx1.o xxx2.o xxx3.o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;错误方法: &lt;code&gt;ar rcs libxxx.a xxx1.c xxx2.c xxx3.c&lt;/code&gt;（静态库可以生成；当运行连接了该静态库的可执行程序会报错：could not read symbols:Archive has no index;run ranlib to add one）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;windows上小熊猫c创建的c语言静态库teststatic-c&#34;&gt;Windows上小熊猫C++创建的C语言静态库&lt;code&gt;TestStatic-C&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc.exe -c hello.c -o hello.o -O2 -pipe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;windres.exe -i TestStatic-C_private.rc --input-format=rc -o TestStatic-C_private.res -O coff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ar r libTestStatic-C.a hello.o TestStatic-C_private.res&lt;/code&gt;
消息&lt;code&gt;ar: creating libTestStatic-C.a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ranlib libTestStatic-C.a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;windows上小熊猫c创建的c语言静态库teststatic-cpp&#34;&gt;Windows上小熊猫C++创建的C语言静态库&lt;code&gt;TestStatic-CPP&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++.exe -c hello.cpp -o hello.o -O2 -std=c++2a -pipe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;windres.exe -i TestStatic-CPP_private.rc --input-format=rc -o TestStatic-CPP_private.res -O coff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ar r libTestStatic-CPP.a hello.o TestStatic-CPP_private.res&lt;/code&gt;
消息&lt;code&gt;ar: creating libTestStatic-CPP.a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ranlib libTestStatic-CPP.a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++.exe -c xxx1.c xxx2.c xxx3.c -O2 -std=c++20 -pipe&lt;/code&gt;&lt;br&gt;
或&lt;code&gt;g++.exe -c xxx1.c -O2 -o xxx1.o -std=c++20 -pipe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ar rcs libxxx.a xxx1.o xxx2.o xxx3.o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ar及其参数说明&#34;&gt;ar及其参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ar 是 Linux 的一个备份压缩命令，它可以将多个文件打包成一个备份文件（也叫归档文件），也可以从备份文件中提取成员文件。ar 命令最常见的用法是将目标文件打包为静态链接库。&lt;/li&gt;
&lt;li&gt;参数r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。&lt;/li&gt;
&lt;li&gt;参数c：创建一个库。不管库是否存在，都将创建。&lt;/li&gt;
&lt;li&gt;参数s：创建目标文件索引，这在创建较大的库时能加快时间。（补充：如果不需要创建索引，可改成大写S参数；如果.a文件缺少索引，可以使用ranlib命令添加）&lt;/li&gt;
&lt;li&gt;有些场合&lt;code&gt;ar rcs&lt;/code&gt;又用&lt;code&gt;ar -rc&lt;/code&gt;、&lt;code&gt;ar -r&lt;/code&gt;、&lt;code&gt;ar r&lt;/code&gt;替代使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链接使用动态库和静态库&#34;&gt;链接(使用)动态库和静态库&lt;/h2&gt;
&lt;h3 id=&#34;方法1-i-头文件目录--l-库文件目录--l库名xxx无前缀lib和后缀名&#34;&gt;方法1：&lt;code&gt;-I 头文件目录 -L 库文件目录 -l库名xxx(无前缀lib和后缀名)&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ main.o -o main -I {INCLUDE_PATH} -L {LIB_PATH} -lname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++ main.cpp -o main -I {INCLUDE_PATH} -L {LIB_PATH} -lname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;举例链接动态库：&lt;br&gt;
&lt;code&gt;g++ main.cpp -o main.exe -O2 -std=c++20 -pipe -s -I  D:\C++Lib\XXX\include -L D:\C++Lib\XXX\lib -lxxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;举例链接静态库：&lt;br&gt;
&lt;code&gt;g++ main.cpp -o main.exe -O2 -std=c++20 -pipe -s -static -I  D:\C++Lib\XXX\include -L D:\C++Lib\XXX\lib -lxxx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法2-i-头文件目录--l-库文件目录--l完整文件名后缀&#34;&gt;方法2：&lt;code&gt;-I 头文件目录 -L 库文件目录 -l:完整文件名+后缀&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ main.o -o main -I {INCLUDE_PATH} -L {LIB_PATH} -l:完整文件名+后缀&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++ main.cpp -o main -I {INCLUDE_PATH} -L {LIB_PATH} -l:完整文件名+后缀&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;举例链接动态库：&lt;br&gt;
&lt;code&gt;g++ main.cpp -o main.exe -O2 -std=c++20 -pipe -s -I D:\C++Lib\XXX\include -L D:\C++Lib\XXX\lib -l:libxxx.dll&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;举例链接静态库：&lt;br&gt;
&lt;code&gt;g++ main.cpp -o main.exe -O2 -std=c++20 -pipe -s -static -I D:\C++Lib\XXX\include -L D:\C++Lib\XXX\lib -l:libxxx.a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法3-i-头文件目录-文件路径完整文件名后缀&#34;&gt;方法3：&lt;code&gt;-I 头文件目录 文件路径+完整文件名+后缀&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ main.o -o main -I {INCLUDE_PATH} {LIB_PATH_AND_LIBNAME}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++ main.cpp -o main -I {INCLUDE_PATH} {LIB_PATH_AND_LIBNAME}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;举例链接动态库：&lt;br&gt;
&lt;code&gt;g++ main.cpp -o main.exe -O2 -std=c++20 -pipe -s -I D:\C++Lib\XXX\include D:\C++Lib\XXX\lib\libxxx.dll&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;举例链接静态库：&lt;br&gt;
&lt;code&gt;g++ main.cpp -o main.exe -O2 -std=c++20 -pipe -s -static -I D:\C++Lib\XXX\include D:\C++Lib\XXX\lib\libxxx.a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;说明&#34;&gt;说明：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-I 头文件目录&lt;/code&gt; 可用设置环境变量&lt;code&gt;set C_INCLUDE_PATH=头文件目录&lt;/code&gt;替代&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L 库文件目录&lt;/code&gt; 可用设置环境变量&lt;code&gt;set LIBRARY_PATH=库文件目录&lt;/code&gt;替代&lt;/li&gt;
&lt;li&gt;&lt;code&gt;文件路径+完整文件名+后缀&lt;/code&gt;不能省略路径，但可以用相对路径，&lt;code&gt;LIBRARY_PATH&lt;/code&gt;对方法3无效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;h3 id=&#34;名称修饰&#34;&gt;名称修饰&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;来关闭名称修饰&lt;/li&gt;
&lt;li&gt;使用编译器选项关闭名称修饰：一些编译器提供了选项来关闭名称修饰，例如在GCC编译器中，可以使用&lt;code&gt;-fno-rtti&lt;/code&gt;选项关闭名称修饰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;函数导出&#34;&gt;函数导出&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MSVC &lt;code&gt;def文件&lt;/code&gt;、&lt;code&gt;__declspec(dllexport)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MinGW64 &lt;code&gt;__declspec(dllexport)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cmake+MinGW64 默认会导出所有函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;环境变量&#34;&gt;环境变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C_INCLUDE_PATH&lt;/code&gt;头文件路径的环境变量：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPLUS_INCLUDE_PATH&lt;/code&gt;头文件路径的环境变量：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIBRARY_PATH&lt;/code&gt;库文件路径的环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;是一个Linux环境变量，用于指定动态链接库的搜索路径。当一个程序运行时，如果需要使用动态链接库，系统会在&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;中指定的路径中搜索相应的库文件，以便程序能够正确运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查看用命令&#34;&gt;查看用命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nm libxxx.a&lt;/code&gt; 查看库中包含的函数信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldd main&lt;/code&gt;查看可执行程序依赖的动态库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fpic和fpic比较&#34;&gt;fpic和fPIC比较&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;相同点：都是为了在动态库中生成位置无关的代码，通过全局偏移表（GOT）访问所有常量地址。程序启动时动态加载程序解析GOT条目。&lt;/li&gt;
&lt;li&gt;不同点：如果链接的可执行文件的GOT大小超过计算机架构特定的最大值，则会在编译链接时报错误消息，提示 -fpic 不起作用；因此在这种情况下，需要使用 -fPIC 重新编译。GOT大小因芯片架构的不同而大小不一样，SPARC上为8k，在AArch64上为28k（笔者遇到的就是它，GOT超出了限制，所以报错），在m68k和RS / 6000上为32k。而x86上没有此限制。&lt;/li&gt;
&lt;li&gt;温馨提示：为了保障程序在跨平台编译时整体可用，通常情况下建议都使用 fPIC&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
